// automatically generated by the FlatBuffers compiler, do not modify

// @generated

use core::cmp::Ordering;
use core::mem;

extern crate flatbuffers;
use self::flatbuffers::{EndianScalar, Follow};

#[allow(unused_imports, dead_code)]
pub mod fb {

    use core::cmp::Ordering;
    use core::mem;

    extern crate flatbuffers;
    use self::flatbuffers::{EndianScalar, Follow};

    pub enum BackupOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct Backup<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for Backup<'a> {
        type Inner = Backup<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> Backup<'a> {
        pub const VT_NAME: flatbuffers::VOffsetT = 4;
        pub const VT_SEED: flatbuffers::VOffsetT = 6;
        pub const VT_INDEX: flatbuffers::VOffsetT = 8;
        pub const VT_SK: flatbuffers::VOffsetT = 10;
        pub const VT_FVK: flatbuffers::VOffsetT = 12;
        pub const VT_UVK: flatbuffers::VOffsetT = 14;
        pub const VT_TSK: flatbuffers::VOffsetT = 16;
        pub const VT_SAVED: flatbuffers::VOffsetT = 18;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            Backup { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<
            'bldr: 'args,
            'args: 'mut_bldr,
            'mut_bldr,
            A: flatbuffers::Allocator + 'bldr,
        >(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
            args: &'args BackupArgs<'args>,
        ) -> flatbuffers::WIPOffset<Backup<'bldr>> {
            let mut builder = BackupBuilder::new(_fbb);
            if let Some(x) = args.tsk {
                builder.add_tsk(x);
            }
            if let Some(x) = args.uvk {
                builder.add_uvk(x);
            }
            if let Some(x) = args.fvk {
                builder.add_fvk(x);
            }
            if let Some(x) = args.sk {
                builder.add_sk(x);
            }
            builder.add_index(args.index);
            if let Some(x) = args.seed {
                builder.add_seed(x);
            }
            if let Some(x) = args.name {
                builder.add_name(x);
            }
            builder.add_saved(args.saved);
            builder.finish()
        }

        pub fn unpack(&self) -> BackupT {
            let name = self.name().map(|x| x.to_string());
            let seed = self.seed().map(|x| x.to_string());
            let index = self.index();
            let sk = self.sk().map(|x| x.to_string());
            let fvk = self.fvk().map(|x| x.to_string());
            let uvk = self.uvk().map(|x| x.to_string());
            let tsk = self.tsk().map(|x| x.to_string());
            let saved = self.saved();
            BackupT {
                name,
                seed,
                index,
                sk,
                fvk,
                uvk,
                tsk,
                saved,
            }
        }

        #[inline]
        pub fn name(&self) -> Option<&'a str> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<&str>>(Backup::VT_NAME, None)
            }
        }
        #[inline]
        pub fn seed(&self) -> Option<&'a str> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<&str>>(Backup::VT_SEED, None)
            }
        }
        #[inline]
        pub fn index(&self) -> u32 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe { self._tab.get::<u32>(Backup::VT_INDEX, Some(0)).unwrap() }
        }
        #[inline]
        pub fn sk(&self) -> Option<&'a str> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<&str>>(Backup::VT_SK, None)
            }
        }
        #[inline]
        pub fn fvk(&self) -> Option<&'a str> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<&str>>(Backup::VT_FVK, None)
            }
        }
        #[inline]
        pub fn uvk(&self) -> Option<&'a str> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<&str>>(Backup::VT_UVK, None)
            }
        }
        #[inline]
        pub fn tsk(&self) -> Option<&'a str> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<&str>>(Backup::VT_TSK, None)
            }
        }
        #[inline]
        pub fn saved(&self) -> bool {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<bool>(Backup::VT_SAVED, Some(false))
                    .unwrap()
            }
        }
    }

    impl flatbuffers::Verifiable for Backup<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<flatbuffers::ForwardsUOffset<&str>>("name", Self::VT_NAME, false)?
                .visit_field::<flatbuffers::ForwardsUOffset<&str>>("seed", Self::VT_SEED, false)?
                .visit_field::<u32>("index", Self::VT_INDEX, false)?
                .visit_field::<flatbuffers::ForwardsUOffset<&str>>("sk", Self::VT_SK, false)?
                .visit_field::<flatbuffers::ForwardsUOffset<&str>>("fvk", Self::VT_FVK, false)?
                .visit_field::<flatbuffers::ForwardsUOffset<&str>>("uvk", Self::VT_UVK, false)?
                .visit_field::<flatbuffers::ForwardsUOffset<&str>>("tsk", Self::VT_TSK, false)?
                .visit_field::<bool>("saved", Self::VT_SAVED, false)?
                .finish();
            Ok(())
        }
    }
    pub struct BackupArgs<'a> {
        pub name: Option<flatbuffers::WIPOffset<&'a str>>,
        pub seed: Option<flatbuffers::WIPOffset<&'a str>>,
        pub index: u32,
        pub sk: Option<flatbuffers::WIPOffset<&'a str>>,
        pub fvk: Option<flatbuffers::WIPOffset<&'a str>>,
        pub uvk: Option<flatbuffers::WIPOffset<&'a str>>,
        pub tsk: Option<flatbuffers::WIPOffset<&'a str>>,
        pub saved: bool,
    }
    impl<'a> Default for BackupArgs<'a> {
        #[inline]
        fn default() -> Self {
            BackupArgs {
                name: None,
                seed: None,
                index: 0,
                sk: None,
                fvk: None,
                uvk: None,
                tsk: None,
                saved: false,
            }
        }
    }

    pub struct BackupBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> BackupBuilder<'a, 'b, A> {
        #[inline]
        pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(Backup::VT_NAME, name);
        }
        #[inline]
        pub fn add_seed(&mut self, seed: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(Backup::VT_SEED, seed);
        }
        #[inline]
        pub fn add_index(&mut self, index: u32) {
            self.fbb_.push_slot::<u32>(Backup::VT_INDEX, index, 0);
        }
        #[inline]
        pub fn add_sk(&mut self, sk: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(Backup::VT_SK, sk);
        }
        #[inline]
        pub fn add_fvk(&mut self, fvk: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(Backup::VT_FVK, fvk);
        }
        #[inline]
        pub fn add_uvk(&mut self, uvk: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(Backup::VT_UVK, uvk);
        }
        #[inline]
        pub fn add_tsk(&mut self, tsk: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(Backup::VT_TSK, tsk);
        }
        #[inline]
        pub fn add_saved(&mut self, saved: bool) {
            self.fbb_.push_slot::<bool>(Backup::VT_SAVED, saved, false);
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        ) -> BackupBuilder<'a, 'b, A> {
            let start = _fbb.start_table();
            BackupBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<Backup<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for Backup<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("Backup");
            ds.field("name", &self.name());
            ds.field("seed", &self.seed());
            ds.field("index", &self.index());
            ds.field("sk", &self.sk());
            ds.field("fvk", &self.fvk());
            ds.field("uvk", &self.uvk());
            ds.field("tsk", &self.tsk());
            ds.field("saved", &self.saved());
            ds.finish()
        }
    }
    #[non_exhaustive]
    #[derive(Debug, Clone, PartialEq)]
    pub struct BackupT {
        pub name: Option<String>,
        pub seed: Option<String>,
        pub index: u32,
        pub sk: Option<String>,
        pub fvk: Option<String>,
        pub uvk: Option<String>,
        pub tsk: Option<String>,
        pub saved: bool,
    }
    impl Default for BackupT {
        fn default() -> Self {
            Self {
                name: None,
                seed: None,
                index: 0,
                sk: None,
                fvk: None,
                uvk: None,
                tsk: None,
                saved: false,
            }
        }
    }
    impl BackupT {
        pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
            &self,
            _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
        ) -> flatbuffers::WIPOffset<Backup<'b>> {
            let name = self.name.as_ref().map(|x| _fbb.create_string(x));
            let seed = self.seed.as_ref().map(|x| _fbb.create_string(x));
            let index = self.index;
            let sk = self.sk.as_ref().map(|x| _fbb.create_string(x));
            let fvk = self.fvk.as_ref().map(|x| _fbb.create_string(x));
            let uvk = self.uvk.as_ref().map(|x| _fbb.create_string(x));
            let tsk = self.tsk.as_ref().map(|x| _fbb.create_string(x));
            let saved = self.saved;
            Backup::create(
                _fbb,
                &BackupArgs {
                    name,
                    seed,
                    index,
                    sk,
                    fvk,
                    uvk,
                    tsk,
                    saved,
                },
            )
        }
    }
    pub enum TransactionInfoOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct TransactionInfo<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for TransactionInfo<'a> {
        type Inner = TransactionInfo<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> TransactionInfo<'a> {
        pub const VT_ID: flatbuffers::VOffsetT = 4;
        pub const VT_TXID: flatbuffers::VOffsetT = 6;
        pub const VT_HEIGHT: flatbuffers::VOffsetT = 8;
        pub const VT_CONFIRMATIONS: flatbuffers::VOffsetT = 10;
        pub const VT_TIMESTAMP: flatbuffers::VOffsetT = 12;
        pub const VT_AMOUNT: flatbuffers::VOffsetT = 14;
        pub const VT_ADDRESS: flatbuffers::VOffsetT = 16;
        pub const VT_CONTACT: flatbuffers::VOffsetT = 18;
        pub const VT_MEMO: flatbuffers::VOffsetT = 20;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            TransactionInfo { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<
            'bldr: 'args,
            'args: 'mut_bldr,
            'mut_bldr,
            A: flatbuffers::Allocator + 'bldr,
        >(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
            args: &'args TransactionInfoArgs<'args>,
        ) -> flatbuffers::WIPOffset<TransactionInfo<'bldr>> {
            let mut builder = TransactionInfoBuilder::new(_fbb);
            builder.add_amount(args.amount);
            if let Some(x) = args.memo {
                builder.add_memo(x);
            }
            if let Some(x) = args.contact {
                builder.add_contact(x);
            }
            if let Some(x) = args.address {
                builder.add_address(x);
            }
            builder.add_timestamp(args.timestamp);
            builder.add_confirmations(args.confirmations);
            builder.add_height(args.height);
            if let Some(x) = args.txid {
                builder.add_txid(x);
            }
            builder.add_id(args.id);
            builder.finish()
        }

        pub fn unpack(&self) -> TransactionInfoT {
            let id = self.id();
            let txid = self.txid().map(|x| x.to_string());
            let height = self.height();
            let confirmations = self.confirmations();
            let timestamp = self.timestamp();
            let amount = self.amount();
            let address = self.address().map(|x| x.to_string());
            let contact = self.contact().map(|x| x.to_string());
            let memo = self.memo().map(|x| x.to_string());
            TransactionInfoT {
                id,
                txid,
                height,
                confirmations,
                timestamp,
                amount,
                address,
                contact,
                memo,
            }
        }

        #[inline]
        pub fn id(&self) -> u32 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<u32>(TransactionInfo::VT_ID, Some(0))
                    .unwrap()
            }
        }
        #[inline]
        pub fn txid(&self) -> Option<&'a str> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<&str>>(TransactionInfo::VT_TXID, None)
            }
        }
        #[inline]
        pub fn height(&self) -> u32 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<u32>(TransactionInfo::VT_HEIGHT, Some(0))
                    .unwrap()
            }
        }
        #[inline]
        pub fn confirmations(&self) -> u32 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<u32>(TransactionInfo::VT_CONFIRMATIONS, Some(0))
                    .unwrap()
            }
        }
        #[inline]
        pub fn timestamp(&self) -> u32 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<u32>(TransactionInfo::VT_TIMESTAMP, Some(0))
                    .unwrap()
            }
        }
        #[inline]
        pub fn amount(&self) -> i64 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<i64>(TransactionInfo::VT_AMOUNT, Some(0))
                    .unwrap()
            }
        }
        #[inline]
        pub fn address(&self) -> Option<&'a str> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<&str>>(TransactionInfo::VT_ADDRESS, None)
            }
        }
        #[inline]
        pub fn contact(&self) -> Option<&'a str> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<&str>>(TransactionInfo::VT_CONTACT, None)
            }
        }
        #[inline]
        pub fn memo(&self) -> Option<&'a str> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<&str>>(TransactionInfo::VT_MEMO, None)
            }
        }
    }

    impl flatbuffers::Verifiable for TransactionInfo<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<u32>("id", Self::VT_ID, false)?
                .visit_field::<flatbuffers::ForwardsUOffset<&str>>("txid", Self::VT_TXID, false)?
                .visit_field::<u32>("height", Self::VT_HEIGHT, false)?
                .visit_field::<u32>("confirmations", Self::VT_CONFIRMATIONS, false)?
                .visit_field::<u32>("timestamp", Self::VT_TIMESTAMP, false)?
                .visit_field::<i64>("amount", Self::VT_AMOUNT, false)?
                .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                    "address",
                    Self::VT_ADDRESS,
                    false,
                )?
                .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                    "contact",
                    Self::VT_CONTACT,
                    false,
                )?
                .visit_field::<flatbuffers::ForwardsUOffset<&str>>("memo", Self::VT_MEMO, false)?
                .finish();
            Ok(())
        }
    }
    pub struct TransactionInfoArgs<'a> {
        pub id: u32,
        pub txid: Option<flatbuffers::WIPOffset<&'a str>>,
        pub height: u32,
        pub confirmations: u32,
        pub timestamp: u32,
        pub amount: i64,
        pub address: Option<flatbuffers::WIPOffset<&'a str>>,
        pub contact: Option<flatbuffers::WIPOffset<&'a str>>,
        pub memo: Option<flatbuffers::WIPOffset<&'a str>>,
    }
    impl<'a> Default for TransactionInfoArgs<'a> {
        #[inline]
        fn default() -> Self {
            TransactionInfoArgs {
                id: 0,
                txid: None,
                height: 0,
                confirmations: 0,
                timestamp: 0,
                amount: 0,
                address: None,
                contact: None,
                memo: None,
            }
        }
    }

    pub struct TransactionInfoBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> TransactionInfoBuilder<'a, 'b, A> {
        #[inline]
        pub fn add_id(&mut self, id: u32) {
            self.fbb_.push_slot::<u32>(TransactionInfo::VT_ID, id, 0);
        }
        #[inline]
        pub fn add_txid(&mut self, txid: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(TransactionInfo::VT_TXID, txid);
        }
        #[inline]
        pub fn add_height(&mut self, height: u32) {
            self.fbb_
                .push_slot::<u32>(TransactionInfo::VT_HEIGHT, height, 0);
        }
        #[inline]
        pub fn add_confirmations(&mut self, confirmations: u32) {
            self.fbb_
                .push_slot::<u32>(TransactionInfo::VT_CONFIRMATIONS, confirmations, 0);
        }
        #[inline]
        pub fn add_timestamp(&mut self, timestamp: u32) {
            self.fbb_
                .push_slot::<u32>(TransactionInfo::VT_TIMESTAMP, timestamp, 0);
        }
        #[inline]
        pub fn add_amount(&mut self, amount: i64) {
            self.fbb_
                .push_slot::<i64>(TransactionInfo::VT_AMOUNT, amount, 0);
        }
        #[inline]
        pub fn add_address(&mut self, address: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                TransactionInfo::VT_ADDRESS,
                address,
            );
        }
        #[inline]
        pub fn add_contact(&mut self, contact: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                TransactionInfo::VT_CONTACT,
                contact,
            );
        }
        #[inline]
        pub fn add_memo(&mut self, memo: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(TransactionInfo::VT_MEMO, memo);
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        ) -> TransactionInfoBuilder<'a, 'b, A> {
            let start = _fbb.start_table();
            TransactionInfoBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<TransactionInfo<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for TransactionInfo<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("TransactionInfo");
            ds.field("id", &self.id());
            ds.field("txid", &self.txid());
            ds.field("height", &self.height());
            ds.field("confirmations", &self.confirmations());
            ds.field("timestamp", &self.timestamp());
            ds.field("amount", &self.amount());
            ds.field("address", &self.address());
            ds.field("contact", &self.contact());
            ds.field("memo", &self.memo());
            ds.finish()
        }
    }
    #[non_exhaustive]
    #[derive(Debug, Clone, PartialEq)]
    pub struct TransactionInfoT {
        pub id: u32,
        pub txid: Option<String>,
        pub height: u32,
        pub confirmations: u32,
        pub timestamp: u32,
        pub amount: i64,
        pub address: Option<String>,
        pub contact: Option<String>,
        pub memo: Option<String>,
    }
    impl Default for TransactionInfoT {
        fn default() -> Self {
            Self {
                id: 0,
                txid: None,
                height: 0,
                confirmations: 0,
                timestamp: 0,
                amount: 0,
                address: None,
                contact: None,
                memo: None,
            }
        }
    }
    impl TransactionInfoT {
        pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
            &self,
            _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
        ) -> flatbuffers::WIPOffset<TransactionInfo<'b>> {
            let id = self.id;
            let txid = self.txid.as_ref().map(|x| _fbb.create_string(x));
            let height = self.height;
            let confirmations = self.confirmations;
            let timestamp = self.timestamp;
            let amount = self.amount;
            let address = self.address.as_ref().map(|x| _fbb.create_string(x));
            let contact = self.contact.as_ref().map(|x| _fbb.create_string(x));
            let memo = self.memo.as_ref().map(|x| _fbb.create_string(x));
            TransactionInfo::create(
                _fbb,
                &TransactionInfoArgs {
                    id,
                    txid,
                    height,
                    confirmations,
                    timestamp,
                    amount,
                    address,
                    contact,
                    memo,
                },
            )
        }
    }
} // pub mod fb
