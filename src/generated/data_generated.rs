// automatically generated by the FlatBuffers compiler, do not modify

// @generated

extern crate flatbuffers;

#[allow(unused_imports, dead_code)]
pub mod fb {

    use core::cmp::Ordering;
    use core::mem;

    extern crate flatbuffers;
    use self::flatbuffers::{EndianScalar, Follow};
    use serde::{Deserialize, Serialize};

    // struct IdNote, aligned to 4
    #[repr(transparent)]
    #[derive(Clone, Copy, PartialEq)]
    pub struct IdNote(pub [u8; 8]);
    impl Default for IdNote {
        fn default() -> Self {
            Self([0; 8])
        }
    }
    impl core::fmt::Debug for IdNote {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            f.debug_struct("IdNote")
                .field("pool", &self.pool())
                .field("id", &self.id())
                .finish()
        }
    }

    impl flatbuffers::SimpleToVerifyInSlice for IdNote {}
    impl<'a> flatbuffers::Follow<'a> for IdNote {
        type Inner = &'a IdNote;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            <&'a IdNote>::follow(buf, loc)
        }
    }
    impl<'a> flatbuffers::Follow<'a> for &'a IdNote {
        type Inner = &'a IdNote;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            flatbuffers::follow_cast_ref::<IdNote>(buf, loc)
        }
    }
    impl<'b> flatbuffers::Push for IdNote {
        type Output = IdNote;
        #[inline]
        unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
            let src =
                ::core::slice::from_raw_parts(self as *const IdNote as *const u8, Self::size());
            dst.copy_from_slice(src);
        }
    }

    impl<'a> flatbuffers::Verifiable for IdNote {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.in_buffer::<Self>(pos)
        }
    }

    impl<'a> IdNote {
        #[allow(clippy::too_many_arguments)]
        pub fn new(pool: u8, id: u32) -> Self {
            let mut s = Self([0; 8]);
            s.set_pool(pool);
            s.set_id(id);
            s
        }

        pub fn pool(&self) -> u8 {
            let mut mem = core::mem::MaybeUninit::<<u8 as EndianScalar>::Scalar>::uninit();
            // Safety:
            // Created from a valid Table for this object
            // Which contains a valid value in this slot
            EndianScalar::from_little_endian(unsafe {
                core::ptr::copy_nonoverlapping(
                    self.0[0..].as_ptr(),
                    mem.as_mut_ptr() as *mut u8,
                    core::mem::size_of::<<u8 as EndianScalar>::Scalar>(),
                );
                mem.assume_init()
            })
        }

        pub fn set_pool(&mut self, x: u8) {
            let x_le = x.to_little_endian();
            // Safety:
            // Created from a valid Table for this object
            // Which contains a valid value in this slot
            unsafe {
                core::ptr::copy_nonoverlapping(
                    &x_le as *const _ as *const u8,
                    self.0[0..].as_mut_ptr(),
                    core::mem::size_of::<<u8 as EndianScalar>::Scalar>(),
                );
            }
        }

        pub fn id(&self) -> u32 {
            let mut mem = core::mem::MaybeUninit::<<u32 as EndianScalar>::Scalar>::uninit();
            // Safety:
            // Created from a valid Table for this object
            // Which contains a valid value in this slot
            EndianScalar::from_little_endian(unsafe {
                core::ptr::copy_nonoverlapping(
                    self.0[4..].as_ptr(),
                    mem.as_mut_ptr() as *mut u8,
                    core::mem::size_of::<<u32 as EndianScalar>::Scalar>(),
                );
                mem.assume_init()
            })
        }

        pub fn set_id(&mut self, x: u32) {
            let x_le = x.to_little_endian();
            // Safety:
            // Created from a valid Table for this object
            // Which contains a valid value in this slot
            unsafe {
                core::ptr::copy_nonoverlapping(
                    &x_le as *const _ as *const u8,
                    self.0[4..].as_mut_ptr(),
                    core::mem::size_of::<<u32 as EndianScalar>::Scalar>(),
                );
            }
        }

        pub fn unpack(&self) -> IdNoteT {
            IdNoteT {
                pool: self.pool(),
                id: self.id(),
            }
        }
    }

    #[derive(Serialize, Deserialize, Debug, Clone, PartialEq, Default)]
    pub struct IdNoteT {
        pub pool: u8,
        pub id: u32,
    }
    impl IdNoteT {
        pub fn pack(&self) -> IdNote {
            IdNote::new(self.pool, self.id)
        }
    }

    pub enum BackupOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct Backup<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for Backup<'a> {
        type Inner = Backup<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> Backup<'a> {
        pub const VT_NAME: flatbuffers::VOffsetT = 4;
        pub const VT_SEED: flatbuffers::VOffsetT = 6;
        pub const VT_INDEX: flatbuffers::VOffsetT = 8;
        pub const VT_SK: flatbuffers::VOffsetT = 10;
        pub const VT_FVK: flatbuffers::VOffsetT = 12;
        pub const VT_UVK: flatbuffers::VOffsetT = 14;
        pub const VT_TSK: flatbuffers::VOffsetT = 16;
        pub const VT_BIRTH: flatbuffers::VOffsetT = 18;
        pub const VT_SAVED: flatbuffers::VOffsetT = 20;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            Backup { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<
            'bldr: 'args,
            'args: 'mut_bldr,
            'mut_bldr,
            A: flatbuffers::Allocator + 'bldr,
        >(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
            args: &'args BackupArgs<'args>,
        ) -> flatbuffers::WIPOffset<Backup<'bldr>> {
            let mut builder = BackupBuilder::new(_fbb);
            builder.add_birth(args.birth);
            if let Some(x) = args.tsk {
                builder.add_tsk(x);
            }
            if let Some(x) = args.uvk {
                builder.add_uvk(x);
            }
            if let Some(x) = args.fvk {
                builder.add_fvk(x);
            }
            if let Some(x) = args.sk {
                builder.add_sk(x);
            }
            builder.add_index(args.index);
            if let Some(x) = args.seed {
                builder.add_seed(x);
            }
            if let Some(x) = args.name {
                builder.add_name(x);
            }
            builder.add_saved(args.saved);
            builder.finish()
        }

        pub fn unpack(&self) -> BackupT {
            let name = self.name().map(|x| x.to_string());
            let seed = self.seed().map(|x| x.to_string());
            let index = self.index();
            let sk = self.sk().map(|x| x.to_string());
            let fvk = self.fvk().map(|x| x.to_string());
            let uvk = self.uvk().map(|x| x.to_string());
            let tsk = self.tsk().map(|x| x.to_string());
            let birth = self.birth();
            let saved = self.saved();
            BackupT {
                name,
                seed,
                index,
                sk,
                fvk,
                uvk,
                tsk,
                birth,
                saved,
            }
        }

        #[inline]
        pub fn name(&self) -> Option<&'a str> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<&str>>(Backup::VT_NAME, None)
            }
        }
        #[inline]
        pub fn seed(&self) -> Option<&'a str> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<&str>>(Backup::VT_SEED, None)
            }
        }
        #[inline]
        pub fn index(&self) -> u32 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe { self._tab.get::<u32>(Backup::VT_INDEX, Some(0)).unwrap() }
        }
        #[inline]
        pub fn sk(&self) -> Option<&'a str> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<&str>>(Backup::VT_SK, None)
            }
        }
        #[inline]
        pub fn fvk(&self) -> Option<&'a str> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<&str>>(Backup::VT_FVK, None)
            }
        }
        #[inline]
        pub fn uvk(&self) -> Option<&'a str> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<&str>>(Backup::VT_UVK, None)
            }
        }
        #[inline]
        pub fn tsk(&self) -> Option<&'a str> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<&str>>(Backup::VT_TSK, None)
            }
        }
        #[inline]
        pub fn birth(&self) -> u32 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe { self._tab.get::<u32>(Backup::VT_BIRTH, Some(0)).unwrap() }
        }
        #[inline]
        pub fn saved(&self) -> bool {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<bool>(Backup::VT_SAVED, Some(false))
                    .unwrap()
            }
        }
    }

    impl flatbuffers::Verifiable for Backup<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<flatbuffers::ForwardsUOffset<&str>>("name", Self::VT_NAME, false)?
                .visit_field::<flatbuffers::ForwardsUOffset<&str>>("seed", Self::VT_SEED, false)?
                .visit_field::<u32>("index", Self::VT_INDEX, false)?
                .visit_field::<flatbuffers::ForwardsUOffset<&str>>("sk", Self::VT_SK, false)?
                .visit_field::<flatbuffers::ForwardsUOffset<&str>>("fvk", Self::VT_FVK, false)?
                .visit_field::<flatbuffers::ForwardsUOffset<&str>>("uvk", Self::VT_UVK, false)?
                .visit_field::<flatbuffers::ForwardsUOffset<&str>>("tsk", Self::VT_TSK, false)?
                .visit_field::<u32>("birth", Self::VT_BIRTH, false)?
                .visit_field::<bool>("saved", Self::VT_SAVED, false)?
                .finish();
            Ok(())
        }
    }
    pub struct BackupArgs<'a> {
        pub name: Option<flatbuffers::WIPOffset<&'a str>>,
        pub seed: Option<flatbuffers::WIPOffset<&'a str>>,
        pub index: u32,
        pub sk: Option<flatbuffers::WIPOffset<&'a str>>,
        pub fvk: Option<flatbuffers::WIPOffset<&'a str>>,
        pub uvk: Option<flatbuffers::WIPOffset<&'a str>>,
        pub tsk: Option<flatbuffers::WIPOffset<&'a str>>,
        pub birth: u32,
        pub saved: bool,
    }
    impl<'a> Default for BackupArgs<'a> {
        #[inline]
        fn default() -> Self {
            BackupArgs {
                name: None,
                seed: None,
                index: 0,
                sk: None,
                fvk: None,
                uvk: None,
                tsk: None,
                birth: 0,
                saved: false,
            }
        }
    }

    pub struct BackupBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> BackupBuilder<'a, 'b, A> {
        #[inline]
        pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(Backup::VT_NAME, name);
        }
        #[inline]
        pub fn add_seed(&mut self, seed: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(Backup::VT_SEED, seed);
        }
        #[inline]
        pub fn add_index(&mut self, index: u32) {
            self.fbb_.push_slot::<u32>(Backup::VT_INDEX, index, 0);
        }
        #[inline]
        pub fn add_sk(&mut self, sk: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(Backup::VT_SK, sk);
        }
        #[inline]
        pub fn add_fvk(&mut self, fvk: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(Backup::VT_FVK, fvk);
        }
        #[inline]
        pub fn add_uvk(&mut self, uvk: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(Backup::VT_UVK, uvk);
        }
        #[inline]
        pub fn add_tsk(&mut self, tsk: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(Backup::VT_TSK, tsk);
        }
        #[inline]
        pub fn add_birth(&mut self, birth: u32) {
            self.fbb_.push_slot::<u32>(Backup::VT_BIRTH, birth, 0);
        }
        #[inline]
        pub fn add_saved(&mut self, saved: bool) {
            self.fbb_.push_slot::<bool>(Backup::VT_SAVED, saved, false);
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        ) -> BackupBuilder<'a, 'b, A> {
            let start = _fbb.start_table();
            BackupBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<Backup<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for Backup<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("Backup");
            ds.field("name", &self.name());
            ds.field("seed", &self.seed());
            ds.field("index", &self.index());
            ds.field("sk", &self.sk());
            ds.field("fvk", &self.fvk());
            ds.field("uvk", &self.uvk());
            ds.field("tsk", &self.tsk());
            ds.field("birth", &self.birth());
            ds.field("saved", &self.saved());
            ds.finish()
        }
    }
    #[non_exhaustive]
    #[derive(Serialize, Deserialize, Debug, Clone, PartialEq)]
    pub struct BackupT {
        pub name: Option<String>,
        pub seed: Option<String>,
        pub index: u32,
        pub sk: Option<String>,
        pub fvk: Option<String>,
        pub uvk: Option<String>,
        pub tsk: Option<String>,
        pub birth: u32,
        pub saved: bool,
    }
    impl Default for BackupT {
        fn default() -> Self {
            Self {
                name: None,
                seed: None,
                index: 0,
                sk: None,
                fvk: None,
                uvk: None,
                tsk: None,
                birth: 0,
                saved: false,
            }
        }
    }
    impl BackupT {
        pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
            &self,
            _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
        ) -> flatbuffers::WIPOffset<Backup<'b>> {
            let name = self.name.as_ref().map(|x| _fbb.create_string(x));
            let seed = self.seed.as_ref().map(|x| _fbb.create_string(x));
            let index = self.index;
            let sk = self.sk.as_ref().map(|x| _fbb.create_string(x));
            let fvk = self.fvk.as_ref().map(|x| _fbb.create_string(x));
            let uvk = self.uvk.as_ref().map(|x| _fbb.create_string(x));
            let tsk = self.tsk.as_ref().map(|x| _fbb.create_string(x));
            let birth = self.birth;
            let saved = self.saved;
            Backup::create(
                _fbb,
                &BackupArgs {
                    name,
                    seed,
                    index,
                    sk,
                    fvk,
                    uvk,
                    tsk,
                    birth,
                    saved,
                },
            )
        }
    }
    pub enum TransactionInfoOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct TransactionInfo<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for TransactionInfo<'a> {
        type Inner = TransactionInfo<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> TransactionInfo<'a> {
        pub const VT_ID: flatbuffers::VOffsetT = 4;
        pub const VT_TXID: flatbuffers::VOffsetT = 6;
        pub const VT_HEIGHT: flatbuffers::VOffsetT = 8;
        pub const VT_CONFIRMATIONS: flatbuffers::VOffsetT = 10;
        pub const VT_TIMESTAMP: flatbuffers::VOffsetT = 12;
        pub const VT_AMOUNT: flatbuffers::VOffsetT = 14;
        pub const VT_ADDRESS: flatbuffers::VOffsetT = 16;
        pub const VT_CONTACT: flatbuffers::VOffsetT = 18;
        pub const VT_MEMO: flatbuffers::VOffsetT = 20;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            TransactionInfo { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<
            'bldr: 'args,
            'args: 'mut_bldr,
            'mut_bldr,
            A: flatbuffers::Allocator + 'bldr,
        >(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
            args: &'args TransactionInfoArgs<'args>,
        ) -> flatbuffers::WIPOffset<TransactionInfo<'bldr>> {
            let mut builder = TransactionInfoBuilder::new(_fbb);
            builder.add_amount(args.amount);
            if let Some(x) = args.memo {
                builder.add_memo(x);
            }
            if let Some(x) = args.contact {
                builder.add_contact(x);
            }
            if let Some(x) = args.address {
                builder.add_address(x);
            }
            builder.add_timestamp(args.timestamp);
            builder.add_confirmations(args.confirmations);
            builder.add_height(args.height);
            if let Some(x) = args.txid {
                builder.add_txid(x);
            }
            builder.add_id(args.id);
            builder.finish()
        }

        pub fn unpack(&self) -> TransactionInfoT {
            let id = self.id();
            let txid = self.txid().map(|x| x.into_iter().collect());
            let height = self.height();
            let confirmations = self.confirmations();
            let timestamp = self.timestamp();
            let amount = self.amount();
            let address = self.address().map(|x| x.to_string());
            let contact = self.contact().map(|x| x.to_string());
            let memo = self.memo().map(|x| x.to_string());
            TransactionInfoT {
                id,
                txid,
                height,
                confirmations,
                timestamp,
                amount,
                address,
                contact,
                memo,
            }
        }

        #[inline]
        pub fn id(&self) -> u32 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<u32>(TransactionInfo::VT_ID, Some(0))
                    .unwrap()
            }
        }
        #[inline]
        pub fn txid(&self) -> Option<flatbuffers::Vector<'a, u8>> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(
                        TransactionInfo::VT_TXID,
                        None,
                    )
            }
        }
        #[inline]
        pub fn height(&self) -> u32 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<u32>(TransactionInfo::VT_HEIGHT, Some(0))
                    .unwrap()
            }
        }
        #[inline]
        pub fn confirmations(&self) -> u32 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<u32>(TransactionInfo::VT_CONFIRMATIONS, Some(0))
                    .unwrap()
            }
        }
        #[inline]
        pub fn timestamp(&self) -> u32 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<u32>(TransactionInfo::VT_TIMESTAMP, Some(0))
                    .unwrap()
            }
        }
        #[inline]
        pub fn amount(&self) -> i64 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<i64>(TransactionInfo::VT_AMOUNT, Some(0))
                    .unwrap()
            }
        }
        #[inline]
        pub fn address(&self) -> Option<&'a str> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<&str>>(TransactionInfo::VT_ADDRESS, None)
            }
        }
        #[inline]
        pub fn contact(&self) -> Option<&'a str> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<&str>>(TransactionInfo::VT_CONTACT, None)
            }
        }
        #[inline]
        pub fn memo(&self) -> Option<&'a str> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<&str>>(TransactionInfo::VT_MEMO, None)
            }
        }
    }

    impl flatbuffers::Verifiable for TransactionInfo<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<u32>("id", Self::VT_ID, false)?
                .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>(
                    "txid",
                    Self::VT_TXID,
                    false,
                )?
                .visit_field::<u32>("height", Self::VT_HEIGHT, false)?
                .visit_field::<u32>("confirmations", Self::VT_CONFIRMATIONS, false)?
                .visit_field::<u32>("timestamp", Self::VT_TIMESTAMP, false)?
                .visit_field::<i64>("amount", Self::VT_AMOUNT, false)?
                .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                    "address",
                    Self::VT_ADDRESS,
                    false,
                )?
                .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                    "contact",
                    Self::VT_CONTACT,
                    false,
                )?
                .visit_field::<flatbuffers::ForwardsUOffset<&str>>("memo", Self::VT_MEMO, false)?
                .finish();
            Ok(())
        }
    }
    pub struct TransactionInfoArgs<'a> {
        pub id: u32,
        pub txid: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
        pub height: u32,
        pub confirmations: u32,
        pub timestamp: u32,
        pub amount: i64,
        pub address: Option<flatbuffers::WIPOffset<&'a str>>,
        pub contact: Option<flatbuffers::WIPOffset<&'a str>>,
        pub memo: Option<flatbuffers::WIPOffset<&'a str>>,
    }
    impl<'a> Default for TransactionInfoArgs<'a> {
        #[inline]
        fn default() -> Self {
            TransactionInfoArgs {
                id: 0,
                txid: None,
                height: 0,
                confirmations: 0,
                timestamp: 0,
                amount: 0,
                address: None,
                contact: None,
                memo: None,
            }
        }
    }

    pub struct TransactionInfoBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> TransactionInfoBuilder<'a, 'b, A> {
        #[inline]
        pub fn add_id(&mut self, id: u32) {
            self.fbb_.push_slot::<u32>(TransactionInfo::VT_ID, id, 0);
        }
        #[inline]
        pub fn add_txid(&mut self, txid: flatbuffers::WIPOffset<flatbuffers::Vector<'b, u8>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(TransactionInfo::VT_TXID, txid);
        }
        #[inline]
        pub fn add_height(&mut self, height: u32) {
            self.fbb_
                .push_slot::<u32>(TransactionInfo::VT_HEIGHT, height, 0);
        }
        #[inline]
        pub fn add_confirmations(&mut self, confirmations: u32) {
            self.fbb_
                .push_slot::<u32>(TransactionInfo::VT_CONFIRMATIONS, confirmations, 0);
        }
        #[inline]
        pub fn add_timestamp(&mut self, timestamp: u32) {
            self.fbb_
                .push_slot::<u32>(TransactionInfo::VT_TIMESTAMP, timestamp, 0);
        }
        #[inline]
        pub fn add_amount(&mut self, amount: i64) {
            self.fbb_
                .push_slot::<i64>(TransactionInfo::VT_AMOUNT, amount, 0);
        }
        #[inline]
        pub fn add_address(&mut self, address: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                TransactionInfo::VT_ADDRESS,
                address,
            );
        }
        #[inline]
        pub fn add_contact(&mut self, contact: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                TransactionInfo::VT_CONTACT,
                contact,
            );
        }
        #[inline]
        pub fn add_memo(&mut self, memo: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(TransactionInfo::VT_MEMO, memo);
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        ) -> TransactionInfoBuilder<'a, 'b, A> {
            let start = _fbb.start_table();
            TransactionInfoBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<TransactionInfo<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for TransactionInfo<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("TransactionInfo");
            ds.field("id", &self.id());
            ds.field("txid", &self.txid());
            ds.field("height", &self.height());
            ds.field("confirmations", &self.confirmations());
            ds.field("timestamp", &self.timestamp());
            ds.field("amount", &self.amount());
            ds.field("address", &self.address());
            ds.field("contact", &self.contact());
            ds.field("memo", &self.memo());
            ds.finish()
        }
    }
    #[non_exhaustive]
    #[derive(Serialize, Deserialize, Debug, Clone, PartialEq)]
    pub struct TransactionInfoT {
        pub id: u32,
        pub txid: Option<Vec<u8>>,
        pub height: u32,
        pub confirmations: u32,
        pub timestamp: u32,
        pub amount: i64,
        pub address: Option<String>,
        pub contact: Option<String>,
        pub memo: Option<String>,
    }
    impl Default for TransactionInfoT {
        fn default() -> Self {
            Self {
                id: 0,
                txid: None,
                height: 0,
                confirmations: 0,
                timestamp: 0,
                amount: 0,
                address: None,
                contact: None,
                memo: None,
            }
        }
    }
    impl TransactionInfoT {
        pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
            &self,
            _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
        ) -> flatbuffers::WIPOffset<TransactionInfo<'b>> {
            let id = self.id;
            let txid = self.txid.as_ref().map(|x| _fbb.create_vector(x));
            let height = self.height;
            let confirmations = self.confirmations;
            let timestamp = self.timestamp;
            let amount = self.amount;
            let address = self.address.as_ref().map(|x| _fbb.create_string(x));
            let contact = self.contact.as_ref().map(|x| _fbb.create_string(x));
            let memo = self.memo.as_ref().map(|x| _fbb.create_string(x));
            TransactionInfo::create(
                _fbb,
                &TransactionInfoArgs {
                    id,
                    txid,
                    height,
                    confirmations,
                    timestamp,
                    amount,
                    address,
                    contact,
                    memo,
                },
            )
        }
    }
    pub enum TransactionInfoExtendedOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct TransactionInfoExtended<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for TransactionInfoExtended<'a> {
        type Inner = TransactionInfoExtended<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> TransactionInfoExtended<'a> {
        pub const VT_HEIGHT: flatbuffers::VOffsetT = 4;
        pub const VT_TIMESTAMP: flatbuffers::VOffsetT = 6;
        pub const VT_TXID: flatbuffers::VOffsetT = 8;
        pub const VT_TINS: flatbuffers::VOffsetT = 10;
        pub const VT_TOUTS: flatbuffers::VOffsetT = 12;
        pub const VT_SINS: flatbuffers::VOffsetT = 14;
        pub const VT_SOUTS: flatbuffers::VOffsetT = 16;
        pub const VT_OINS: flatbuffers::VOffsetT = 18;
        pub const VT_OOUTS: flatbuffers::VOffsetT = 20;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            TransactionInfoExtended { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<
            'bldr: 'args,
            'args: 'mut_bldr,
            'mut_bldr,
            A: flatbuffers::Allocator + 'bldr,
        >(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
            args: &'args TransactionInfoExtendedArgs<'args>,
        ) -> flatbuffers::WIPOffset<TransactionInfoExtended<'bldr>> {
            let mut builder = TransactionInfoExtendedBuilder::new(_fbb);
            if let Some(x) = args.oouts {
                builder.add_oouts(x);
            }
            if let Some(x) = args.oins {
                builder.add_oins(x);
            }
            if let Some(x) = args.souts {
                builder.add_souts(x);
            }
            if let Some(x) = args.sins {
                builder.add_sins(x);
            }
            if let Some(x) = args.touts {
                builder.add_touts(x);
            }
            if let Some(x) = args.tins {
                builder.add_tins(x);
            }
            if let Some(x) = args.txid {
                builder.add_txid(x);
            }
            builder.add_timestamp(args.timestamp);
            builder.add_height(args.height);
            builder.finish()
        }

        pub fn unpack(&self) -> TransactionInfoExtendedT {
            let height = self.height();
            let timestamp = self.timestamp();
            let txid = self.txid().map(|x| x.into_iter().collect());
            let tins = self.tins().map(|x| x.iter().map(|t| t.unpack()).collect());
            let touts = self.touts().map(|x| x.iter().map(|t| t.unpack()).collect());
            let sins = self.sins().map(|x| x.iter().map(|t| t.unpack()).collect());
            let souts = self.souts().map(|x| x.iter().map(|t| t.unpack()).collect());
            let oins = self.oins().map(|x| x.iter().map(|t| t.unpack()).collect());
            let oouts = self.oouts().map(|x| x.iter().map(|t| t.unpack()).collect());
            TransactionInfoExtendedT {
                height,
                timestamp,
                txid,
                tins,
                touts,
                sins,
                souts,
                oins,
                oouts,
            }
        }

        #[inline]
        pub fn height(&self) -> u32 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<u32>(TransactionInfoExtended::VT_HEIGHT, Some(0))
                    .unwrap()
            }
        }
        #[inline]
        pub fn timestamp(&self) -> u32 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<u32>(TransactionInfoExtended::VT_TIMESTAMP, Some(0))
                    .unwrap()
            }
        }
        #[inline]
        pub fn txid(&self) -> Option<flatbuffers::Vector<'a, u8>> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(
                        TransactionInfoExtended::VT_TXID,
                        None,
                    )
            }
        }
        #[inline]
        pub fn tins(
            &self,
        ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<InputTransparent<'a>>>>
        {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab.get::<flatbuffers::ForwardsUOffset<
                    flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<InputTransparent>>,
                >>(TransactionInfoExtended::VT_TINS, None)
            }
        }
        #[inline]
        pub fn touts(
            &self,
        ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<OutputTransparent<'a>>>>
        {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab.get::<flatbuffers::ForwardsUOffset<
                    flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<OutputTransparent>>,
                >>(TransactionInfoExtended::VT_TOUTS, None)
            }
        }
        #[inline]
        pub fn sins(
            &self,
        ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<InputShielded<'a>>>>
        {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab.get::<flatbuffers::ForwardsUOffset<
                    flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<InputShielded>>,
                >>(TransactionInfoExtended::VT_SINS, None)
            }
        }
        #[inline]
        pub fn souts(
            &self,
        ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<OutputShielded<'a>>>>
        {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab.get::<flatbuffers::ForwardsUOffset<
                    flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<OutputShielded>>,
                >>(TransactionInfoExtended::VT_SOUTS, None)
            }
        }
        #[inline]
        pub fn oins(
            &self,
        ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<InputShielded<'a>>>>
        {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab.get::<flatbuffers::ForwardsUOffset<
                    flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<InputShielded>>,
                >>(TransactionInfoExtended::VT_OINS, None)
            }
        }
        #[inline]
        pub fn oouts(
            &self,
        ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<OutputShielded<'a>>>>
        {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab.get::<flatbuffers::ForwardsUOffset<
                    flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<OutputShielded>>,
                >>(TransactionInfoExtended::VT_OOUTS, None)
            }
        }
    }

    impl flatbuffers::Verifiable for TransactionInfoExtended<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<u32>("height", Self::VT_HEIGHT, false)?
                .visit_field::<u32>("timestamp", Self::VT_TIMESTAMP, false)?
                .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>(
                    "txid",
                    Self::VT_TXID,
                    false,
                )?
                .visit_field::<flatbuffers::ForwardsUOffset<
                    flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<InputTransparent>>,
                >>("tins", Self::VT_TINS, false)?
                .visit_field::<flatbuffers::ForwardsUOffset<
                    flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<OutputTransparent>>,
                >>("touts", Self::VT_TOUTS, false)?
                .visit_field::<flatbuffers::ForwardsUOffset<
                    flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<InputShielded>>,
                >>("sins", Self::VT_SINS, false)?
                .visit_field::<flatbuffers::ForwardsUOffset<
                    flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<OutputShielded>>,
                >>("souts", Self::VT_SOUTS, false)?
                .visit_field::<flatbuffers::ForwardsUOffset<
                    flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<InputShielded>>,
                >>("oins", Self::VT_OINS, false)?
                .visit_field::<flatbuffers::ForwardsUOffset<
                    flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<OutputShielded>>,
                >>("oouts", Self::VT_OOUTS, false)?
                .finish();
            Ok(())
        }
    }
    pub struct TransactionInfoExtendedArgs<'a> {
        pub height: u32,
        pub timestamp: u32,
        pub txid: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
        pub tins: Option<
            flatbuffers::WIPOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<InputTransparent<'a>>>,
            >,
        >,
        pub touts: Option<
            flatbuffers::WIPOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<OutputTransparent<'a>>>,
            >,
        >,
        pub sins: Option<
            flatbuffers::WIPOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<InputShielded<'a>>>,
            >,
        >,
        pub souts: Option<
            flatbuffers::WIPOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<OutputShielded<'a>>>,
            >,
        >,
        pub oins: Option<
            flatbuffers::WIPOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<InputShielded<'a>>>,
            >,
        >,
        pub oouts: Option<
            flatbuffers::WIPOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<OutputShielded<'a>>>,
            >,
        >,
    }
    impl<'a> Default for TransactionInfoExtendedArgs<'a> {
        #[inline]
        fn default() -> Self {
            TransactionInfoExtendedArgs {
                height: 0,
                timestamp: 0,
                txid: None,
                tins: None,
                touts: None,
                sins: None,
                souts: None,
                oins: None,
                oouts: None,
            }
        }
    }

    pub struct TransactionInfoExtendedBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> TransactionInfoExtendedBuilder<'a, 'b, A> {
        #[inline]
        pub fn add_height(&mut self, height: u32) {
            self.fbb_
                .push_slot::<u32>(TransactionInfoExtended::VT_HEIGHT, height, 0);
        }
        #[inline]
        pub fn add_timestamp(&mut self, timestamp: u32) {
            self.fbb_
                .push_slot::<u32>(TransactionInfoExtended::VT_TIMESTAMP, timestamp, 0);
        }
        #[inline]
        pub fn add_txid(&mut self, txid: flatbuffers::WIPOffset<flatbuffers::Vector<'b, u8>>) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                TransactionInfoExtended::VT_TXID,
                txid,
            );
        }
        #[inline]
        pub fn add_tins(
            &mut self,
            tins: flatbuffers::WIPOffset<
                flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<InputTransparent<'b>>>,
            >,
        ) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                TransactionInfoExtended::VT_TINS,
                tins,
            );
        }
        #[inline]
        pub fn add_touts(
            &mut self,
            touts: flatbuffers::WIPOffset<
                flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<OutputTransparent<'b>>>,
            >,
        ) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                TransactionInfoExtended::VT_TOUTS,
                touts,
            );
        }
        #[inline]
        pub fn add_sins(
            &mut self,
            sins: flatbuffers::WIPOffset<
                flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<InputShielded<'b>>>,
            >,
        ) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                TransactionInfoExtended::VT_SINS,
                sins,
            );
        }
        #[inline]
        pub fn add_souts(
            &mut self,
            souts: flatbuffers::WIPOffset<
                flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<OutputShielded<'b>>>,
            >,
        ) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                TransactionInfoExtended::VT_SOUTS,
                souts,
            );
        }
        #[inline]
        pub fn add_oins(
            &mut self,
            oins: flatbuffers::WIPOffset<
                flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<InputShielded<'b>>>,
            >,
        ) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                TransactionInfoExtended::VT_OINS,
                oins,
            );
        }
        #[inline]
        pub fn add_oouts(
            &mut self,
            oouts: flatbuffers::WIPOffset<
                flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<OutputShielded<'b>>>,
            >,
        ) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                TransactionInfoExtended::VT_OOUTS,
                oouts,
            );
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        ) -> TransactionInfoExtendedBuilder<'a, 'b, A> {
            let start = _fbb.start_table();
            TransactionInfoExtendedBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<TransactionInfoExtended<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for TransactionInfoExtended<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("TransactionInfoExtended");
            ds.field("height", &self.height());
            ds.field("timestamp", &self.timestamp());
            ds.field("txid", &self.txid());
            ds.field("tins", &self.tins());
            ds.field("touts", &self.touts());
            ds.field("sins", &self.sins());
            ds.field("souts", &self.souts());
            ds.field("oins", &self.oins());
            ds.field("oouts", &self.oouts());
            ds.finish()
        }
    }
    #[non_exhaustive]
    #[derive(Serialize, Deserialize, Debug, Clone, PartialEq)]
    pub struct TransactionInfoExtendedT {
        pub height: u32,
        pub timestamp: u32,
        pub txid: Option<Vec<u8>>,
        pub tins: Option<Vec<InputTransparentT>>,
        pub touts: Option<Vec<OutputTransparentT>>,
        pub sins: Option<Vec<InputShieldedT>>,
        pub souts: Option<Vec<OutputShieldedT>>,
        pub oins: Option<Vec<InputShieldedT>>,
        pub oouts: Option<Vec<OutputShieldedT>>,
    }
    impl Default for TransactionInfoExtendedT {
        fn default() -> Self {
            Self {
                height: 0,
                timestamp: 0,
                txid: None,
                tins: None,
                touts: None,
                sins: None,
                souts: None,
                oins: None,
                oouts: None,
            }
        }
    }
    impl TransactionInfoExtendedT {
        pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
            &self,
            _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
        ) -> flatbuffers::WIPOffset<TransactionInfoExtended<'b>> {
            let height = self.height;
            let timestamp = self.timestamp;
            let txid = self.txid.as_ref().map(|x| _fbb.create_vector(x));
            let tins = self.tins.as_ref().map(|x| {
                let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
                _fbb.create_vector(&w)
            });
            let touts = self.touts.as_ref().map(|x| {
                let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
                _fbb.create_vector(&w)
            });
            let sins = self.sins.as_ref().map(|x| {
                let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
                _fbb.create_vector(&w)
            });
            let souts = self.souts.as_ref().map(|x| {
                let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
                _fbb.create_vector(&w)
            });
            let oins = self.oins.as_ref().map(|x| {
                let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
                _fbb.create_vector(&w)
            });
            let oouts = self.oouts.as_ref().map(|x| {
                let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
                _fbb.create_vector(&w)
            });
            TransactionInfoExtended::create(
                _fbb,
                &TransactionInfoExtendedArgs {
                    height,
                    timestamp,
                    txid,
                    tins,
                    touts,
                    sins,
                    souts,
                    oins,
                    oouts,
                },
            )
        }
    }
    pub enum InputTransparentOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct InputTransparent<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for InputTransparent<'a> {
        type Inner = InputTransparent<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> InputTransparent<'a> {
        pub const VT_TXID: flatbuffers::VOffsetT = 4;
        pub const VT_VOUT: flatbuffers::VOffsetT = 6;
        pub const VT_ADDRESS: flatbuffers::VOffsetT = 8;
        pub const VT_VALUE: flatbuffers::VOffsetT = 10;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            InputTransparent { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<
            'bldr: 'args,
            'args: 'mut_bldr,
            'mut_bldr,
            A: flatbuffers::Allocator + 'bldr,
        >(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
            args: &'args InputTransparentArgs<'args>,
        ) -> flatbuffers::WIPOffset<InputTransparent<'bldr>> {
            let mut builder = InputTransparentBuilder::new(_fbb);
            builder.add_value(args.value);
            if let Some(x) = args.address {
                builder.add_address(x);
            }
            builder.add_vout(args.vout);
            if let Some(x) = args.txid {
                builder.add_txid(x);
            }
            builder.finish()
        }

        pub fn unpack(&self) -> InputTransparentT {
            let txid = self.txid().map(|x| x.into_iter().collect());
            let vout = self.vout();
            let address = self.address().map(|x| x.to_string());
            let value = self.value();
            InputTransparentT {
                txid,
                vout,
                address,
                value,
            }
        }

        #[inline]
        pub fn txid(&self) -> Option<flatbuffers::Vector<'a, u8>> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(
                        InputTransparent::VT_TXID,
                        None,
                    )
            }
        }
        #[inline]
        pub fn vout(&self) -> u32 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<u32>(InputTransparent::VT_VOUT, Some(0))
                    .unwrap()
            }
        }
        #[inline]
        pub fn address(&self) -> Option<&'a str> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<&str>>(InputTransparent::VT_ADDRESS, None)
            }
        }
        #[inline]
        pub fn value(&self) -> u64 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<u64>(InputTransparent::VT_VALUE, Some(0))
                    .unwrap()
            }
        }
    }

    impl flatbuffers::Verifiable for InputTransparent<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>(
                    "txid",
                    Self::VT_TXID,
                    false,
                )?
                .visit_field::<u32>("vout", Self::VT_VOUT, false)?
                .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                    "address",
                    Self::VT_ADDRESS,
                    false,
                )?
                .visit_field::<u64>("value", Self::VT_VALUE, false)?
                .finish();
            Ok(())
        }
    }
    pub struct InputTransparentArgs<'a> {
        pub txid: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
        pub vout: u32,
        pub address: Option<flatbuffers::WIPOffset<&'a str>>,
        pub value: u64,
    }
    impl<'a> Default for InputTransparentArgs<'a> {
        #[inline]
        fn default() -> Self {
            InputTransparentArgs {
                txid: None,
                vout: 0,
                address: None,
                value: 0,
            }
        }
    }

    pub struct InputTransparentBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> InputTransparentBuilder<'a, 'b, A> {
        #[inline]
        pub fn add_txid(&mut self, txid: flatbuffers::WIPOffset<flatbuffers::Vector<'b, u8>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(InputTransparent::VT_TXID, txid);
        }
        #[inline]
        pub fn add_vout(&mut self, vout: u32) {
            self.fbb_
                .push_slot::<u32>(InputTransparent::VT_VOUT, vout, 0);
        }
        #[inline]
        pub fn add_address(&mut self, address: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                InputTransparent::VT_ADDRESS,
                address,
            );
        }
        #[inline]
        pub fn add_value(&mut self, value: u64) {
            self.fbb_
                .push_slot::<u64>(InputTransparent::VT_VALUE, value, 0);
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        ) -> InputTransparentBuilder<'a, 'b, A> {
            let start = _fbb.start_table();
            InputTransparentBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<InputTransparent<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for InputTransparent<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("InputTransparent");
            ds.field("txid", &self.txid());
            ds.field("vout", &self.vout());
            ds.field("address", &self.address());
            ds.field("value", &self.value());
            ds.finish()
        }
    }
    #[non_exhaustive]
    #[derive(Serialize, Deserialize, Debug, Clone, PartialEq)]
    pub struct InputTransparentT {
        pub txid: Option<Vec<u8>>,
        pub vout: u32,
        pub address: Option<String>,
        pub value: u64,
    }
    impl Default for InputTransparentT {
        fn default() -> Self {
            Self {
                txid: None,
                vout: 0,
                address: None,
                value: 0,
            }
        }
    }
    impl InputTransparentT {
        pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
            &self,
            _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
        ) -> flatbuffers::WIPOffset<InputTransparent<'b>> {
            let txid = self.txid.as_ref().map(|x| _fbb.create_vector(x));
            let vout = self.vout;
            let address = self.address.as_ref().map(|x| _fbb.create_string(x));
            let value = self.value;
            InputTransparent::create(
                _fbb,
                &InputTransparentArgs {
                    txid,
                    vout,
                    address,
                    value,
                },
            )
        }
    }
    pub enum OutputTransparentOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct OutputTransparent<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for OutputTransparent<'a> {
        type Inner = OutputTransparent<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> OutputTransparent<'a> {
        pub const VT_ADDRESS: flatbuffers::VOffsetT = 4;
        pub const VT_VALUE: flatbuffers::VOffsetT = 6;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            OutputTransparent { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<
            'bldr: 'args,
            'args: 'mut_bldr,
            'mut_bldr,
            A: flatbuffers::Allocator + 'bldr,
        >(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
            args: &'args OutputTransparentArgs<'args>,
        ) -> flatbuffers::WIPOffset<OutputTransparent<'bldr>> {
            let mut builder = OutputTransparentBuilder::new(_fbb);
            builder.add_value(args.value);
            if let Some(x) = args.address {
                builder.add_address(x);
            }
            builder.finish()
        }

        pub fn unpack(&self) -> OutputTransparentT {
            let address = self.address().map(|x| x.to_string());
            let value = self.value();
            OutputTransparentT { address, value }
        }

        #[inline]
        pub fn address(&self) -> Option<&'a str> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<&str>>(OutputTransparent::VT_ADDRESS, None)
            }
        }
        #[inline]
        pub fn value(&self) -> u64 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<u64>(OutputTransparent::VT_VALUE, Some(0))
                    .unwrap()
            }
        }
    }

    impl flatbuffers::Verifiable for OutputTransparent<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                    "address",
                    Self::VT_ADDRESS,
                    false,
                )?
                .visit_field::<u64>("value", Self::VT_VALUE, false)?
                .finish();
            Ok(())
        }
    }
    pub struct OutputTransparentArgs<'a> {
        pub address: Option<flatbuffers::WIPOffset<&'a str>>,
        pub value: u64,
    }
    impl<'a> Default for OutputTransparentArgs<'a> {
        #[inline]
        fn default() -> Self {
            OutputTransparentArgs {
                address: None,
                value: 0,
            }
        }
    }

    pub struct OutputTransparentBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> OutputTransparentBuilder<'a, 'b, A> {
        #[inline]
        pub fn add_address(&mut self, address: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                OutputTransparent::VT_ADDRESS,
                address,
            );
        }
        #[inline]
        pub fn add_value(&mut self, value: u64) {
            self.fbb_
                .push_slot::<u64>(OutputTransparent::VT_VALUE, value, 0);
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        ) -> OutputTransparentBuilder<'a, 'b, A> {
            let start = _fbb.start_table();
            OutputTransparentBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<OutputTransparent<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for OutputTransparent<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("OutputTransparent");
            ds.field("address", &self.address());
            ds.field("value", &self.value());
            ds.finish()
        }
    }
    #[non_exhaustive]
    #[derive(Serialize, Deserialize, Debug, Clone, PartialEq)]
    pub struct OutputTransparentT {
        pub address: Option<String>,
        pub value: u64,
    }
    impl Default for OutputTransparentT {
        fn default() -> Self {
            Self {
                address: None,
                value: 0,
            }
        }
    }
    impl OutputTransparentT {
        pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
            &self,
            _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
        ) -> flatbuffers::WIPOffset<OutputTransparent<'b>> {
            let address = self.address.as_ref().map(|x| _fbb.create_string(x));
            let value = self.value;
            OutputTransparent::create(_fbb, &OutputTransparentArgs { address, value })
        }
    }
    pub enum InputShieldedOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct InputShielded<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for InputShielded<'a> {
        type Inner = InputShielded<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> InputShielded<'a> {
        pub const VT_NF: flatbuffers::VOffsetT = 4;
        pub const VT_ADDRESS: flatbuffers::VOffsetT = 6;
        pub const VT_VALUE: flatbuffers::VOffsetT = 8;
        pub const VT_RCM: flatbuffers::VOffsetT = 10;
        pub const VT_RHO: flatbuffers::VOffsetT = 12;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            InputShielded { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<
            'bldr: 'args,
            'args: 'mut_bldr,
            'mut_bldr,
            A: flatbuffers::Allocator + 'bldr,
        >(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
            args: &'args InputShieldedArgs<'args>,
        ) -> flatbuffers::WIPOffset<InputShielded<'bldr>> {
            let mut builder = InputShieldedBuilder::new(_fbb);
            builder.add_value(args.value);
            if let Some(x) = args.rho {
                builder.add_rho(x);
            }
            if let Some(x) = args.rcm {
                builder.add_rcm(x);
            }
            if let Some(x) = args.address {
                builder.add_address(x);
            }
            if let Some(x) = args.nf {
                builder.add_nf(x);
            }
            builder.finish()
        }

        pub fn unpack(&self) -> InputShieldedT {
            let nf = self.nf().map(|x| x.into_iter().collect());
            let address = self.address().map(|x| x.to_string());
            let value = self.value();
            let rcm = self.rcm().map(|x| x.into_iter().collect());
            let rho = self.rho().map(|x| x.into_iter().collect());
            InputShieldedT {
                nf,
                address,
                value,
                rcm,
                rho,
            }
        }

        #[inline]
        pub fn nf(&self) -> Option<flatbuffers::Vector<'a, u8>> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(
                        InputShielded::VT_NF,
                        None,
                    )
            }
        }
        #[inline]
        pub fn address(&self) -> Option<&'a str> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<&str>>(InputShielded::VT_ADDRESS, None)
            }
        }
        #[inline]
        pub fn value(&self) -> u64 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<u64>(InputShielded::VT_VALUE, Some(0))
                    .unwrap()
            }
        }
        #[inline]
        pub fn rcm(&self) -> Option<flatbuffers::Vector<'a, u8>> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(
                        InputShielded::VT_RCM,
                        None,
                    )
            }
        }
        #[inline]
        pub fn rho(&self) -> Option<flatbuffers::Vector<'a, u8>> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(
                        InputShielded::VT_RHO,
                        None,
                    )
            }
        }
    }

    impl flatbuffers::Verifiable for InputShielded<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>(
                    "nf",
                    Self::VT_NF,
                    false,
                )?
                .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                    "address",
                    Self::VT_ADDRESS,
                    false,
                )?
                .visit_field::<u64>("value", Self::VT_VALUE, false)?
                .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>(
                    "rcm",
                    Self::VT_RCM,
                    false,
                )?
                .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>(
                    "rho",
                    Self::VT_RHO,
                    false,
                )?
                .finish();
            Ok(())
        }
    }
    pub struct InputShieldedArgs<'a> {
        pub nf: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
        pub address: Option<flatbuffers::WIPOffset<&'a str>>,
        pub value: u64,
        pub rcm: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
        pub rho: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
    }
    impl<'a> Default for InputShieldedArgs<'a> {
        #[inline]
        fn default() -> Self {
            InputShieldedArgs {
                nf: None,
                address: None,
                value: 0,
                rcm: None,
                rho: None,
            }
        }
    }

    pub struct InputShieldedBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> InputShieldedBuilder<'a, 'b, A> {
        #[inline]
        pub fn add_nf(&mut self, nf: flatbuffers::WIPOffset<flatbuffers::Vector<'b, u8>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(InputShielded::VT_NF, nf);
        }
        #[inline]
        pub fn add_address(&mut self, address: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(InputShielded::VT_ADDRESS, address);
        }
        #[inline]
        pub fn add_value(&mut self, value: u64) {
            self.fbb_
                .push_slot::<u64>(InputShielded::VT_VALUE, value, 0);
        }
        #[inline]
        pub fn add_rcm(&mut self, rcm: flatbuffers::WIPOffset<flatbuffers::Vector<'b, u8>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(InputShielded::VT_RCM, rcm);
        }
        #[inline]
        pub fn add_rho(&mut self, rho: flatbuffers::WIPOffset<flatbuffers::Vector<'b, u8>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(InputShielded::VT_RHO, rho);
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        ) -> InputShieldedBuilder<'a, 'b, A> {
            let start = _fbb.start_table();
            InputShieldedBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<InputShielded<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for InputShielded<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("InputShielded");
            ds.field("nf", &self.nf());
            ds.field("address", &self.address());
            ds.field("value", &self.value());
            ds.field("rcm", &self.rcm());
            ds.field("rho", &self.rho());
            ds.finish()
        }
    }
    #[non_exhaustive]
    #[derive(Serialize, Deserialize, Debug, Clone, PartialEq)]
    pub struct InputShieldedT {
        pub nf: Option<Vec<u8>>,
        pub address: Option<String>,
        pub value: u64,
        pub rcm: Option<Vec<u8>>,
        pub rho: Option<Vec<u8>>,
    }
    impl Default for InputShieldedT {
        fn default() -> Self {
            Self {
                nf: None,
                address: None,
                value: 0,
                rcm: None,
                rho: None,
            }
        }
    }
    impl InputShieldedT {
        pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
            &self,
            _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
        ) -> flatbuffers::WIPOffset<InputShielded<'b>> {
            let nf = self.nf.as_ref().map(|x| _fbb.create_vector(x));
            let address = self.address.as_ref().map(|x| _fbb.create_string(x));
            let value = self.value;
            let rcm = self.rcm.as_ref().map(|x| _fbb.create_vector(x));
            let rho = self.rho.as_ref().map(|x| _fbb.create_vector(x));
            InputShielded::create(
                _fbb,
                &InputShieldedArgs {
                    nf,
                    address,
                    value,
                    rcm,
                    rho,
                },
            )
        }
    }
    pub enum OutputShieldedOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct OutputShielded<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for OutputShielded<'a> {
        type Inner = OutputShielded<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> OutputShielded<'a> {
        pub const VT_INCOMING: flatbuffers::VOffsetT = 4;
        pub const VT_CMX: flatbuffers::VOffsetT = 6;
        pub const VT_ADDRESS: flatbuffers::VOffsetT = 8;
        pub const VT_VALUE: flatbuffers::VOffsetT = 10;
        pub const VT_RCM: flatbuffers::VOffsetT = 12;
        pub const VT_RHO: flatbuffers::VOffsetT = 14;
        pub const VT_MEMO: flatbuffers::VOffsetT = 16;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            OutputShielded { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<
            'bldr: 'args,
            'args: 'mut_bldr,
            'mut_bldr,
            A: flatbuffers::Allocator + 'bldr,
        >(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
            args: &'args OutputShieldedArgs<'args>,
        ) -> flatbuffers::WIPOffset<OutputShielded<'bldr>> {
            let mut builder = OutputShieldedBuilder::new(_fbb);
            builder.add_value(args.value);
            if let Some(x) = args.memo {
                builder.add_memo(x);
            }
            if let Some(x) = args.rho {
                builder.add_rho(x);
            }
            if let Some(x) = args.rcm {
                builder.add_rcm(x);
            }
            if let Some(x) = args.address {
                builder.add_address(x);
            }
            if let Some(x) = args.cmx {
                builder.add_cmx(x);
            }
            builder.add_incoming(args.incoming);
            builder.finish()
        }

        pub fn unpack(&self) -> OutputShieldedT {
            let incoming = self.incoming();
            let cmx = self.cmx().map(|x| x.into_iter().collect());
            let address = self.address().map(|x| x.to_string());
            let value = self.value();
            let rcm = self.rcm().map(|x| x.into_iter().collect());
            let rho = self.rho().map(|x| x.into_iter().collect());
            let memo = self.memo().map(|x| x.to_string());
            OutputShieldedT {
                incoming,
                cmx,
                address,
                value,
                rcm,
                rho,
                memo,
            }
        }

        #[inline]
        pub fn incoming(&self) -> bool {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<bool>(OutputShielded::VT_INCOMING, Some(false))
                    .unwrap()
            }
        }
        #[inline]
        pub fn cmx(&self) -> Option<flatbuffers::Vector<'a, u8>> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(
                        OutputShielded::VT_CMX,
                        None,
                    )
            }
        }
        #[inline]
        pub fn address(&self) -> Option<&'a str> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<&str>>(OutputShielded::VT_ADDRESS, None)
            }
        }
        #[inline]
        pub fn value(&self) -> u64 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<u64>(OutputShielded::VT_VALUE, Some(0))
                    .unwrap()
            }
        }
        #[inline]
        pub fn rcm(&self) -> Option<flatbuffers::Vector<'a, u8>> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(
                        OutputShielded::VT_RCM,
                        None,
                    )
            }
        }
        #[inline]
        pub fn rho(&self) -> Option<flatbuffers::Vector<'a, u8>> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(
                        OutputShielded::VT_RHO,
                        None,
                    )
            }
        }
        #[inline]
        pub fn memo(&self) -> Option<&'a str> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<&str>>(OutputShielded::VT_MEMO, None)
            }
        }
    }

    impl flatbuffers::Verifiable for OutputShielded<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<bool>("incoming", Self::VT_INCOMING, false)?
                .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>(
                    "cmx",
                    Self::VT_CMX,
                    false,
                )?
                .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                    "address",
                    Self::VT_ADDRESS,
                    false,
                )?
                .visit_field::<u64>("value", Self::VT_VALUE, false)?
                .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>(
                    "rcm",
                    Self::VT_RCM,
                    false,
                )?
                .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>(
                    "rho",
                    Self::VT_RHO,
                    false,
                )?
                .visit_field::<flatbuffers::ForwardsUOffset<&str>>("memo", Self::VT_MEMO, false)?
                .finish();
            Ok(())
        }
    }
    pub struct OutputShieldedArgs<'a> {
        pub incoming: bool,
        pub cmx: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
        pub address: Option<flatbuffers::WIPOffset<&'a str>>,
        pub value: u64,
        pub rcm: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
        pub rho: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
        pub memo: Option<flatbuffers::WIPOffset<&'a str>>,
    }
    impl<'a> Default for OutputShieldedArgs<'a> {
        #[inline]
        fn default() -> Self {
            OutputShieldedArgs {
                incoming: false,
                cmx: None,
                address: None,
                value: 0,
                rcm: None,
                rho: None,
                memo: None,
            }
        }
    }

    pub struct OutputShieldedBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> OutputShieldedBuilder<'a, 'b, A> {
        #[inline]
        pub fn add_incoming(&mut self, incoming: bool) {
            self.fbb_
                .push_slot::<bool>(OutputShielded::VT_INCOMING, incoming, false);
        }
        #[inline]
        pub fn add_cmx(&mut self, cmx: flatbuffers::WIPOffset<flatbuffers::Vector<'b, u8>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(OutputShielded::VT_CMX, cmx);
        }
        #[inline]
        pub fn add_address(&mut self, address: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(OutputShielded::VT_ADDRESS, address);
        }
        #[inline]
        pub fn add_value(&mut self, value: u64) {
            self.fbb_
                .push_slot::<u64>(OutputShielded::VT_VALUE, value, 0);
        }
        #[inline]
        pub fn add_rcm(&mut self, rcm: flatbuffers::WIPOffset<flatbuffers::Vector<'b, u8>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(OutputShielded::VT_RCM, rcm);
        }
        #[inline]
        pub fn add_rho(&mut self, rho: flatbuffers::WIPOffset<flatbuffers::Vector<'b, u8>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(OutputShielded::VT_RHO, rho);
        }
        #[inline]
        pub fn add_memo(&mut self, memo: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(OutputShielded::VT_MEMO, memo);
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        ) -> OutputShieldedBuilder<'a, 'b, A> {
            let start = _fbb.start_table();
            OutputShieldedBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<OutputShielded<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for OutputShielded<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("OutputShielded");
            ds.field("incoming", &self.incoming());
            ds.field("cmx", &self.cmx());
            ds.field("address", &self.address());
            ds.field("value", &self.value());
            ds.field("rcm", &self.rcm());
            ds.field("rho", &self.rho());
            ds.field("memo", &self.memo());
            ds.finish()
        }
    }
    #[non_exhaustive]
    #[derive(Serialize, Deserialize, Debug, Clone, PartialEq)]
    pub struct OutputShieldedT {
        pub incoming: bool,
        pub cmx: Option<Vec<u8>>,
        pub address: Option<String>,
        pub value: u64,
        pub rcm: Option<Vec<u8>>,
        pub rho: Option<Vec<u8>>,
        pub memo: Option<String>,
    }
    impl Default for OutputShieldedT {
        fn default() -> Self {
            Self {
                incoming: false,
                cmx: None,
                address: None,
                value: 0,
                rcm: None,
                rho: None,
                memo: None,
            }
        }
    }
    impl OutputShieldedT {
        pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
            &self,
            _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
        ) -> flatbuffers::WIPOffset<OutputShielded<'b>> {
            let incoming = self.incoming;
            let cmx = self.cmx.as_ref().map(|x| _fbb.create_vector(x));
            let address = self.address.as_ref().map(|x| _fbb.create_string(x));
            let value = self.value;
            let rcm = self.rcm.as_ref().map(|x| _fbb.create_vector(x));
            let rho = self.rho.as_ref().map(|x| _fbb.create_vector(x));
            let memo = self.memo.as_ref().map(|x| _fbb.create_string(x));
            OutputShielded::create(
                _fbb,
                &OutputShieldedArgs {
                    incoming,
                    cmx,
                    address,
                    value,
                    rcm,
                    rho,
                    memo,
                },
            )
        }
    }
    pub enum ShieldedNoteOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct ShieldedNote<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for ShieldedNote<'a> {
        type Inner = ShieldedNote<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> ShieldedNote<'a> {
        pub const VT_ID_NOTE: flatbuffers::VOffsetT = 4;
        pub const VT_HEIGHT: flatbuffers::VOffsetT = 6;
        pub const VT_CONFIRMATIONS: flatbuffers::VOffsetT = 8;
        pub const VT_TIMESTAMP: flatbuffers::VOffsetT = 10;
        pub const VT_VALUE: flatbuffers::VOffsetT = 12;
        pub const VT_ORCHARD: flatbuffers::VOffsetT = 14;
        pub const VT_EXCLUDED: flatbuffers::VOffsetT = 16;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            ShieldedNote { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<
            'bldr: 'args,
            'args: 'mut_bldr,
            'mut_bldr,
            A: flatbuffers::Allocator + 'bldr,
        >(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
            args: &'args ShieldedNoteArgs,
        ) -> flatbuffers::WIPOffset<ShieldedNote<'bldr>> {
            let mut builder = ShieldedNoteBuilder::new(_fbb);
            builder.add_value(args.value);
            builder.add_timestamp(args.timestamp);
            builder.add_confirmations(args.confirmations);
            builder.add_height(args.height);
            builder.add_id_note(args.id_note);
            builder.add_excluded(args.excluded);
            builder.add_orchard(args.orchard);
            builder.finish()
        }

        pub fn unpack(&self) -> ShieldedNoteT {
            let id_note = self.id_note();
            let height = self.height();
            let confirmations = self.confirmations();
            let timestamp = self.timestamp();
            let value = self.value();
            let orchard = self.orchard();
            let excluded = self.excluded();
            ShieldedNoteT {
                id_note,
                height,
                confirmations,
                timestamp,
                value,
                orchard,
                excluded,
            }
        }

        #[inline]
        pub fn id_note(&self) -> u32 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<u32>(ShieldedNote::VT_ID_NOTE, Some(0))
                    .unwrap()
            }
        }
        #[inline]
        pub fn height(&self) -> u32 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<u32>(ShieldedNote::VT_HEIGHT, Some(0))
                    .unwrap()
            }
        }
        #[inline]
        pub fn confirmations(&self) -> u32 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<u32>(ShieldedNote::VT_CONFIRMATIONS, Some(0))
                    .unwrap()
            }
        }
        #[inline]
        pub fn timestamp(&self) -> u32 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<u32>(ShieldedNote::VT_TIMESTAMP, Some(0))
                    .unwrap()
            }
        }
        #[inline]
        pub fn value(&self) -> u64 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<u64>(ShieldedNote::VT_VALUE, Some(0))
                    .unwrap()
            }
        }
        #[inline]
        pub fn orchard(&self) -> bool {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<bool>(ShieldedNote::VT_ORCHARD, Some(false))
                    .unwrap()
            }
        }
        #[inline]
        pub fn excluded(&self) -> bool {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<bool>(ShieldedNote::VT_EXCLUDED, Some(false))
                    .unwrap()
            }
        }
    }

    impl flatbuffers::Verifiable for ShieldedNote<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<u32>("id_note", Self::VT_ID_NOTE, false)?
                .visit_field::<u32>("height", Self::VT_HEIGHT, false)?
                .visit_field::<u32>("confirmations", Self::VT_CONFIRMATIONS, false)?
                .visit_field::<u32>("timestamp", Self::VT_TIMESTAMP, false)?
                .visit_field::<u64>("value", Self::VT_VALUE, false)?
                .visit_field::<bool>("orchard", Self::VT_ORCHARD, false)?
                .visit_field::<bool>("excluded", Self::VT_EXCLUDED, false)?
                .finish();
            Ok(())
        }
    }
    pub struct ShieldedNoteArgs {
        pub id_note: u32,
        pub height: u32,
        pub confirmations: u32,
        pub timestamp: u32,
        pub value: u64,
        pub orchard: bool,
        pub excluded: bool,
    }
    impl<'a> Default for ShieldedNoteArgs {
        #[inline]
        fn default() -> Self {
            ShieldedNoteArgs {
                id_note: 0,
                height: 0,
                confirmations: 0,
                timestamp: 0,
                value: 0,
                orchard: false,
                excluded: false,
            }
        }
    }

    pub struct ShieldedNoteBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> ShieldedNoteBuilder<'a, 'b, A> {
        #[inline]
        pub fn add_id_note(&mut self, id_note: u32) {
            self.fbb_
                .push_slot::<u32>(ShieldedNote::VT_ID_NOTE, id_note, 0);
        }
        #[inline]
        pub fn add_height(&mut self, height: u32) {
            self.fbb_
                .push_slot::<u32>(ShieldedNote::VT_HEIGHT, height, 0);
        }
        #[inline]
        pub fn add_confirmations(&mut self, confirmations: u32) {
            self.fbb_
                .push_slot::<u32>(ShieldedNote::VT_CONFIRMATIONS, confirmations, 0);
        }
        #[inline]
        pub fn add_timestamp(&mut self, timestamp: u32) {
            self.fbb_
                .push_slot::<u32>(ShieldedNote::VT_TIMESTAMP, timestamp, 0);
        }
        #[inline]
        pub fn add_value(&mut self, value: u64) {
            self.fbb_.push_slot::<u64>(ShieldedNote::VT_VALUE, value, 0);
        }
        #[inline]
        pub fn add_orchard(&mut self, orchard: bool) {
            self.fbb_
                .push_slot::<bool>(ShieldedNote::VT_ORCHARD, orchard, false);
        }
        #[inline]
        pub fn add_excluded(&mut self, excluded: bool) {
            self.fbb_
                .push_slot::<bool>(ShieldedNote::VT_EXCLUDED, excluded, false);
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        ) -> ShieldedNoteBuilder<'a, 'b, A> {
            let start = _fbb.start_table();
            ShieldedNoteBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<ShieldedNote<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for ShieldedNote<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("ShieldedNote");
            ds.field("id_note", &self.id_note());
            ds.field("height", &self.height());
            ds.field("confirmations", &self.confirmations());
            ds.field("timestamp", &self.timestamp());
            ds.field("value", &self.value());
            ds.field("orchard", &self.orchard());
            ds.field("excluded", &self.excluded());
            ds.finish()
        }
    }
    #[non_exhaustive]
    #[derive(Serialize, Deserialize, Debug, Clone, PartialEq)]
    pub struct ShieldedNoteT {
        pub id_note: u32,
        pub height: u32,
        pub confirmations: u32,
        pub timestamp: u32,
        pub value: u64,
        pub orchard: bool,
        pub excluded: bool,
    }
    impl Default for ShieldedNoteT {
        fn default() -> Self {
            Self {
                id_note: 0,
                height: 0,
                confirmations: 0,
                timestamp: 0,
                value: 0,
                orchard: false,
                excluded: false,
            }
        }
    }
    impl ShieldedNoteT {
        pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
            &self,
            _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
        ) -> flatbuffers::WIPOffset<ShieldedNote<'b>> {
            let id_note = self.id_note;
            let height = self.height;
            let confirmations = self.confirmations;
            let timestamp = self.timestamp;
            let value = self.value;
            let orchard = self.orchard;
            let excluded = self.excluded;
            ShieldedNote::create(
                _fbb,
                &ShieldedNoteArgs {
                    id_note,
                    height,
                    confirmations,
                    timestamp,
                    value,
                    orchard,
                    excluded,
                },
            )
        }
    }
    pub enum ShieldedMessageOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct ShieldedMessage<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for ShieldedMessage<'a> {
        type Inner = ShieldedMessage<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> ShieldedMessage<'a> {
        pub const VT_ID_MSG: flatbuffers::VOffsetT = 4;
        pub const VT_ACCOUNT: flatbuffers::VOffsetT = 6;
        pub const VT_ID_TX: flatbuffers::VOffsetT = 8;
        pub const VT_TXID: flatbuffers::VOffsetT = 10;
        pub const VT_HEIGHT: flatbuffers::VOffsetT = 12;
        pub const VT_TIMESTAMP: flatbuffers::VOffsetT = 14;
        pub const VT_INCOMING: flatbuffers::VOffsetT = 16;
        pub const VT_CONTACT: flatbuffers::VOffsetT = 18;
        pub const VT_NOUT: flatbuffers::VOffsetT = 20;
        pub const VT_MEMO: flatbuffers::VOffsetT = 22;
        pub const VT_READ: flatbuffers::VOffsetT = 24;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            ShieldedMessage { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<
            'bldr: 'args,
            'args: 'mut_bldr,
            'mut_bldr,
            A: flatbuffers::Allocator + 'bldr,
        >(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
            args: &'args ShieldedMessageArgs<'args>,
        ) -> flatbuffers::WIPOffset<ShieldedMessage<'bldr>> {
            let mut builder = ShieldedMessageBuilder::new(_fbb);
            if let Some(x) = args.memo {
                builder.add_memo(x);
            }
            builder.add_nout(args.nout);
            if let Some(x) = args.contact {
                builder.add_contact(x);
            }
            builder.add_timestamp(args.timestamp);
            builder.add_height(args.height);
            if let Some(x) = args.txid {
                builder.add_txid(x);
            }
            builder.add_id_tx(args.id_tx);
            builder.add_account(args.account);
            builder.add_id_msg(args.id_msg);
            builder.add_read(args.read);
            builder.add_incoming(args.incoming);
            builder.finish()
        }

        pub fn unpack(&self) -> ShieldedMessageT {
            let id_msg = self.id_msg();
            let account = self.account();
            let id_tx = self.id_tx();
            let txid = self.txid().map(|x| x.into_iter().collect());
            let height = self.height();
            let timestamp = self.timestamp();
            let incoming = self.incoming();
            let contact = self.contact().map(|x| x.to_string());
            let nout = self.nout();
            let memo = self.memo().map(|x| Box::new(x.unpack()));
            let read = self.read();
            ShieldedMessageT {
                id_msg,
                account,
                id_tx,
                txid,
                height,
                timestamp,
                incoming,
                contact,
                nout,
                memo,
                read,
            }
        }

        #[inline]
        pub fn id_msg(&self) -> u32 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<u32>(ShieldedMessage::VT_ID_MSG, Some(0))
                    .unwrap()
            }
        }
        #[inline]
        pub fn account(&self) -> u32 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<u32>(ShieldedMessage::VT_ACCOUNT, Some(0))
                    .unwrap()
            }
        }
        #[inline]
        pub fn id_tx(&self) -> u32 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<u32>(ShieldedMessage::VT_ID_TX, Some(0))
                    .unwrap()
            }
        }
        #[inline]
        pub fn txid(&self) -> Option<flatbuffers::Vector<'a, u8>> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(
                        ShieldedMessage::VT_TXID,
                        None,
                    )
            }
        }
        #[inline]
        pub fn height(&self) -> u32 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<u32>(ShieldedMessage::VT_HEIGHT, Some(0))
                    .unwrap()
            }
        }
        #[inline]
        pub fn timestamp(&self) -> u32 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<u32>(ShieldedMessage::VT_TIMESTAMP, Some(0))
                    .unwrap()
            }
        }
        #[inline]
        pub fn incoming(&self) -> bool {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<bool>(ShieldedMessage::VT_INCOMING, Some(false))
                    .unwrap()
            }
        }
        #[inline]
        pub fn contact(&self) -> Option<&'a str> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<&str>>(ShieldedMessage::VT_CONTACT, None)
            }
        }
        #[inline]
        pub fn nout(&self) -> u32 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<u32>(ShieldedMessage::VT_NOUT, Some(0))
                    .unwrap()
            }
        }
        #[inline]
        pub fn memo(&self) -> Option<UserMemo<'a>> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<UserMemo>>(ShieldedMessage::VT_MEMO, None)
            }
        }
        #[inline]
        pub fn read(&self) -> bool {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<bool>(ShieldedMessage::VT_READ, Some(false))
                    .unwrap()
            }
        }
    }

    impl flatbuffers::Verifiable for ShieldedMessage<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<u32>("id_msg", Self::VT_ID_MSG, false)?
                .visit_field::<u32>("account", Self::VT_ACCOUNT, false)?
                .visit_field::<u32>("id_tx", Self::VT_ID_TX, false)?
                .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>(
                    "txid",
                    Self::VT_TXID,
                    false,
                )?
                .visit_field::<u32>("height", Self::VT_HEIGHT, false)?
                .visit_field::<u32>("timestamp", Self::VT_TIMESTAMP, false)?
                .visit_field::<bool>("incoming", Self::VT_INCOMING, false)?
                .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                    "contact",
                    Self::VT_CONTACT,
                    false,
                )?
                .visit_field::<u32>("nout", Self::VT_NOUT, false)?
                .visit_field::<flatbuffers::ForwardsUOffset<UserMemo>>(
                    "memo",
                    Self::VT_MEMO,
                    false,
                )?
                .visit_field::<bool>("read", Self::VT_READ, false)?
                .finish();
            Ok(())
        }
    }
    pub struct ShieldedMessageArgs<'a> {
        pub id_msg: u32,
        pub account: u32,
        pub id_tx: u32,
        pub txid: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
        pub height: u32,
        pub timestamp: u32,
        pub incoming: bool,
        pub contact: Option<flatbuffers::WIPOffset<&'a str>>,
        pub nout: u32,
        pub memo: Option<flatbuffers::WIPOffset<UserMemo<'a>>>,
        pub read: bool,
    }
    impl<'a> Default for ShieldedMessageArgs<'a> {
        #[inline]
        fn default() -> Self {
            ShieldedMessageArgs {
                id_msg: 0,
                account: 0,
                id_tx: 0,
                txid: None,
                height: 0,
                timestamp: 0,
                incoming: false,
                contact: None,
                nout: 0,
                memo: None,
                read: false,
            }
        }
    }

    pub struct ShieldedMessageBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> ShieldedMessageBuilder<'a, 'b, A> {
        #[inline]
        pub fn add_id_msg(&mut self, id_msg: u32) {
            self.fbb_
                .push_slot::<u32>(ShieldedMessage::VT_ID_MSG, id_msg, 0);
        }
        #[inline]
        pub fn add_account(&mut self, account: u32) {
            self.fbb_
                .push_slot::<u32>(ShieldedMessage::VT_ACCOUNT, account, 0);
        }
        #[inline]
        pub fn add_id_tx(&mut self, id_tx: u32) {
            self.fbb_
                .push_slot::<u32>(ShieldedMessage::VT_ID_TX, id_tx, 0);
        }
        #[inline]
        pub fn add_txid(&mut self, txid: flatbuffers::WIPOffset<flatbuffers::Vector<'b, u8>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(ShieldedMessage::VT_TXID, txid);
        }
        #[inline]
        pub fn add_height(&mut self, height: u32) {
            self.fbb_
                .push_slot::<u32>(ShieldedMessage::VT_HEIGHT, height, 0);
        }
        #[inline]
        pub fn add_timestamp(&mut self, timestamp: u32) {
            self.fbb_
                .push_slot::<u32>(ShieldedMessage::VT_TIMESTAMP, timestamp, 0);
        }
        #[inline]
        pub fn add_incoming(&mut self, incoming: bool) {
            self.fbb_
                .push_slot::<bool>(ShieldedMessage::VT_INCOMING, incoming, false);
        }
        #[inline]
        pub fn add_contact(&mut self, contact: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                ShieldedMessage::VT_CONTACT,
                contact,
            );
        }
        #[inline]
        pub fn add_nout(&mut self, nout: u32) {
            self.fbb_
                .push_slot::<u32>(ShieldedMessage::VT_NOUT, nout, 0);
        }
        #[inline]
        pub fn add_memo(&mut self, memo: flatbuffers::WIPOffset<UserMemo<'b>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<UserMemo>>(
                    ShieldedMessage::VT_MEMO,
                    memo,
                );
        }
        #[inline]
        pub fn add_read(&mut self, read: bool) {
            self.fbb_
                .push_slot::<bool>(ShieldedMessage::VT_READ, read, false);
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        ) -> ShieldedMessageBuilder<'a, 'b, A> {
            let start = _fbb.start_table();
            ShieldedMessageBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<ShieldedMessage<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for ShieldedMessage<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("ShieldedMessage");
            ds.field("id_msg", &self.id_msg());
            ds.field("account", &self.account());
            ds.field("id_tx", &self.id_tx());
            ds.field("txid", &self.txid());
            ds.field("height", &self.height());
            ds.field("timestamp", &self.timestamp());
            ds.field("incoming", &self.incoming());
            ds.field("contact", &self.contact());
            ds.field("nout", &self.nout());
            ds.field("memo", &self.memo());
            ds.field("read", &self.read());
            ds.finish()
        }
    }
    #[non_exhaustive]
    #[derive(Serialize, Deserialize, Debug, Clone, PartialEq)]
    pub struct ShieldedMessageT {
        pub id_msg: u32,
        pub account: u32,
        pub id_tx: u32,
        pub txid: Option<Vec<u8>>,
        pub height: u32,
        pub timestamp: u32,
        pub incoming: bool,
        pub contact: Option<String>,
        pub nout: u32,
        pub memo: Option<Box<UserMemoT>>,
        pub read: bool,
    }
    impl Default for ShieldedMessageT {
        fn default() -> Self {
            Self {
                id_msg: 0,
                account: 0,
                id_tx: 0,
                txid: None,
                height: 0,
                timestamp: 0,
                incoming: false,
                contact: None,
                nout: 0,
                memo: None,
                read: false,
            }
        }
    }
    impl ShieldedMessageT {
        pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
            &self,
            _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
        ) -> flatbuffers::WIPOffset<ShieldedMessage<'b>> {
            let id_msg = self.id_msg;
            let account = self.account;
            let id_tx = self.id_tx;
            let txid = self.txid.as_ref().map(|x| _fbb.create_vector(x));
            let height = self.height;
            let timestamp = self.timestamp;
            let incoming = self.incoming;
            let contact = self.contact.as_ref().map(|x| _fbb.create_string(x));
            let nout = self.nout;
            let memo = self.memo.as_ref().map(|x| x.pack(_fbb));
            let read = self.read;
            ShieldedMessage::create(
                _fbb,
                &ShieldedMessageArgs {
                    id_msg,
                    account,
                    id_tx,
                    txid,
                    height,
                    timestamp,
                    incoming,
                    contact,
                    nout,
                    memo,
                    read,
                },
            )
        }
    }
    pub enum UAReceiversOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct UAReceivers<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for UAReceivers<'a> {
        type Inner = UAReceivers<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> UAReceivers<'a> {
        pub const VT_TEX: flatbuffers::VOffsetT = 4;
        pub const VT_TRANSPARENT: flatbuffers::VOffsetT = 6;
        pub const VT_SAPLING: flatbuffers::VOffsetT = 8;
        pub const VT_ORCHARD: flatbuffers::VOffsetT = 10;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            UAReceivers { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<
            'bldr: 'args,
            'args: 'mut_bldr,
            'mut_bldr,
            A: flatbuffers::Allocator + 'bldr,
        >(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
            args: &'args UAReceiversArgs<'args>,
        ) -> flatbuffers::WIPOffset<UAReceivers<'bldr>> {
            let mut builder = UAReceiversBuilder::new(_fbb);
            if let Some(x) = args.orchard {
                builder.add_orchard(x);
            }
            if let Some(x) = args.sapling {
                builder.add_sapling(x);
            }
            if let Some(x) = args.transparent {
                builder.add_transparent(x);
            }
            builder.add_tex(args.tex);
            builder.finish()
        }

        pub fn unpack(&self) -> UAReceiversT {
            let tex = self.tex();
            let transparent = self.transparent().map(|x| x.to_string());
            let sapling = self.sapling().map(|x| x.to_string());
            let orchard = self.orchard().map(|x| x.to_string());
            UAReceiversT {
                tex,
                transparent,
                sapling,
                orchard,
            }
        }

        #[inline]
        pub fn tex(&self) -> bool {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<bool>(UAReceivers::VT_TEX, Some(false))
                    .unwrap()
            }
        }
        #[inline]
        pub fn transparent(&self) -> Option<&'a str> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<&str>>(UAReceivers::VT_TRANSPARENT, None)
            }
        }
        #[inline]
        pub fn sapling(&self) -> Option<&'a str> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<&str>>(UAReceivers::VT_SAPLING, None)
            }
        }
        #[inline]
        pub fn orchard(&self) -> Option<&'a str> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<&str>>(UAReceivers::VT_ORCHARD, None)
            }
        }
    }

    impl flatbuffers::Verifiable for UAReceivers<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<bool>("tex", Self::VT_TEX, false)?
                .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                    "transparent",
                    Self::VT_TRANSPARENT,
                    false,
                )?
                .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                    "sapling",
                    Self::VT_SAPLING,
                    false,
                )?
                .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                    "orchard",
                    Self::VT_ORCHARD,
                    false,
                )?
                .finish();
            Ok(())
        }
    }
    pub struct UAReceiversArgs<'a> {
        pub tex: bool,
        pub transparent: Option<flatbuffers::WIPOffset<&'a str>>,
        pub sapling: Option<flatbuffers::WIPOffset<&'a str>>,
        pub orchard: Option<flatbuffers::WIPOffset<&'a str>>,
    }
    impl<'a> Default for UAReceiversArgs<'a> {
        #[inline]
        fn default() -> Self {
            UAReceiversArgs {
                tex: false,
                transparent: None,
                sapling: None,
                orchard: None,
            }
        }
    }

    pub struct UAReceiversBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> UAReceiversBuilder<'a, 'b, A> {
        #[inline]
        pub fn add_tex(&mut self, tex: bool) {
            self.fbb_.push_slot::<bool>(UAReceivers::VT_TEX, tex, false);
        }
        #[inline]
        pub fn add_transparent(&mut self, transparent: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                UAReceivers::VT_TRANSPARENT,
                transparent,
            );
        }
        #[inline]
        pub fn add_sapling(&mut self, sapling: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(UAReceivers::VT_SAPLING, sapling);
        }
        #[inline]
        pub fn add_orchard(&mut self, orchard: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(UAReceivers::VT_ORCHARD, orchard);
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        ) -> UAReceiversBuilder<'a, 'b, A> {
            let start = _fbb.start_table();
            UAReceiversBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<UAReceivers<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for UAReceivers<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("UAReceivers");
            ds.field("tex", &self.tex());
            ds.field("transparent", &self.transparent());
            ds.field("sapling", &self.sapling());
            ds.field("orchard", &self.orchard());
            ds.finish()
        }
    }
    #[non_exhaustive]
    #[derive(Serialize, Deserialize, Debug, Clone, PartialEq)]
    pub struct UAReceiversT {
        pub tex: bool,
        pub transparent: Option<String>,
        pub sapling: Option<String>,
        pub orchard: Option<String>,
    }
    impl Default for UAReceiversT {
        fn default() -> Self {
            Self {
                tex: false,
                transparent: None,
                sapling: None,
                orchard: None,
            }
        }
    }
    impl UAReceiversT {
        pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
            &self,
            _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
        ) -> flatbuffers::WIPOffset<UAReceivers<'b>> {
            let tex = self.tex;
            let transparent = self.transparent.as_ref().map(|x| _fbb.create_string(x));
            let sapling = self.sapling.as_ref().map(|x| _fbb.create_string(x));
            let orchard = self.orchard.as_ref().map(|x| _fbb.create_string(x));
            UAReceivers::create(
                _fbb,
                &UAReceiversArgs {
                    tex,
                    transparent,
                    sapling,
                    orchard,
                },
            )
        }
    }
    pub enum RecipientOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct Recipient<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for Recipient<'a> {
        type Inner = Recipient<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> Recipient<'a> {
        pub const VT_ADDRESS: flatbuffers::VOffsetT = 4;
        pub const VT_AMOUNT: flatbuffers::VOffsetT = 6;
        pub const VT_POOLS: flatbuffers::VOffsetT = 8;
        pub const VT_MEMO: flatbuffers::VOffsetT = 10;
        pub const VT_MEMO_BYTES: flatbuffers::VOffsetT = 12;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            Recipient { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<
            'bldr: 'args,
            'args: 'mut_bldr,
            'mut_bldr,
            A: flatbuffers::Allocator + 'bldr,
        >(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
            args: &'args RecipientArgs<'args>,
        ) -> flatbuffers::WIPOffset<Recipient<'bldr>> {
            let mut builder = RecipientBuilder::new(_fbb);
            builder.add_amount(args.amount);
            if let Some(x) = args.memo_bytes {
                builder.add_memo_bytes(x);
            }
            if let Some(x) = args.memo {
                builder.add_memo(x);
            }
            if let Some(x) = args.address {
                builder.add_address(x);
            }
            builder.add_pools(args.pools);
            builder.finish()
        }

        pub fn unpack(&self) -> RecipientT {
            let address = self.address().map(|x| x.to_string());
            let amount = self.amount();
            let pools = self.pools();
            let memo = self.memo().map(|x| Box::new(x.unpack()));
            let memo_bytes = self.memo_bytes().map(|x| x.into_iter().collect());
            RecipientT {
                address,
                amount,
                pools,
                memo,
                memo_bytes,
            }
        }

        #[inline]
        pub fn address(&self) -> Option<&'a str> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<&str>>(Recipient::VT_ADDRESS, None)
            }
        }
        #[inline]
        pub fn amount(&self) -> u64 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe { self._tab.get::<u64>(Recipient::VT_AMOUNT, Some(0)).unwrap() }
        }
        #[inline]
        pub fn pools(&self) -> u8 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe { self._tab.get::<u8>(Recipient::VT_POOLS, Some(0)).unwrap() }
        }
        #[inline]
        pub fn memo(&self) -> Option<UserMemo<'a>> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<UserMemo>>(Recipient::VT_MEMO, None)
            }
        }
        #[inline]
        pub fn memo_bytes(&self) -> Option<flatbuffers::Vector<'a, u8>> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(
                        Recipient::VT_MEMO_BYTES,
                        None,
                    )
            }
        }
    }

    impl flatbuffers::Verifiable for Recipient<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                    "address",
                    Self::VT_ADDRESS,
                    false,
                )?
                .visit_field::<u64>("amount", Self::VT_AMOUNT, false)?
                .visit_field::<u8>("pools", Self::VT_POOLS, false)?
                .visit_field::<flatbuffers::ForwardsUOffset<UserMemo>>(
                    "memo",
                    Self::VT_MEMO,
                    false,
                )?
                .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>(
                    "memo_bytes",
                    Self::VT_MEMO_BYTES,
                    false,
                )?
                .finish();
            Ok(())
        }
    }
    pub struct RecipientArgs<'a> {
        pub address: Option<flatbuffers::WIPOffset<&'a str>>,
        pub amount: u64,
        pub pools: u8,
        pub memo: Option<flatbuffers::WIPOffset<UserMemo<'a>>>,
        pub memo_bytes: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
    }
    impl<'a> Default for RecipientArgs<'a> {
        #[inline]
        fn default() -> Self {
            RecipientArgs {
                address: None,
                amount: 0,
                pools: 0,
                memo: None,
                memo_bytes: None,
            }
        }
    }

    pub struct RecipientBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> RecipientBuilder<'a, 'b, A> {
        #[inline]
        pub fn add_address(&mut self, address: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(Recipient::VT_ADDRESS, address);
        }
        #[inline]
        pub fn add_amount(&mut self, amount: u64) {
            self.fbb_.push_slot::<u64>(Recipient::VT_AMOUNT, amount, 0);
        }
        #[inline]
        pub fn add_pools(&mut self, pools: u8) {
            self.fbb_.push_slot::<u8>(Recipient::VT_POOLS, pools, 0);
        }
        #[inline]
        pub fn add_memo(&mut self, memo: flatbuffers::WIPOffset<UserMemo<'b>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<UserMemo>>(Recipient::VT_MEMO, memo);
        }
        #[inline]
        pub fn add_memo_bytes(
            &mut self,
            memo_bytes: flatbuffers::WIPOffset<flatbuffers::Vector<'b, u8>>,
        ) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                Recipient::VT_MEMO_BYTES,
                memo_bytes,
            );
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        ) -> RecipientBuilder<'a, 'b, A> {
            let start = _fbb.start_table();
            RecipientBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<Recipient<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for Recipient<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("Recipient");
            ds.field("address", &self.address());
            ds.field("amount", &self.amount());
            ds.field("pools", &self.pools());
            ds.field("memo", &self.memo());
            ds.field("memo_bytes", &self.memo_bytes());
            ds.finish()
        }
    }
    #[non_exhaustive]
    #[derive(Serialize, Deserialize, Debug, Clone, PartialEq)]
    pub struct RecipientT {
        pub address: Option<String>,
        pub amount: u64,
        pub pools: u8,
        pub memo: Option<Box<UserMemoT>>,
        pub memo_bytes: Option<Vec<u8>>,
    }
    impl Default for RecipientT {
        fn default() -> Self {
            Self {
                address: None,
                amount: 0,
                pools: 0,
                memo: None,
                memo_bytes: None,
            }
        }
    }
    impl RecipientT {
        pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
            &self,
            _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
        ) -> flatbuffers::WIPOffset<Recipient<'b>> {
            let address = self.address.as_ref().map(|x| _fbb.create_string(x));
            let amount = self.amount;
            let pools = self.pools;
            let memo = self.memo.as_ref().map(|x| x.pack(_fbb));
            let memo_bytes = self.memo_bytes.as_ref().map(|x| _fbb.create_vector(x));
            Recipient::create(
                _fbb,
                &RecipientArgs {
                    address,
                    amount,
                    pools,
                    memo,
                    memo_bytes,
                },
            )
        }
    }
    pub enum PaymentRequestOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct PaymentRequest<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for PaymentRequest<'a> {
        type Inner = PaymentRequest<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> PaymentRequest<'a> {
        pub const VT_RECIPIENTS: flatbuffers::VOffsetT = 4;
        pub const VT_SRC_POOLS: flatbuffers::VOffsetT = 6;
        pub const VT_SENDER_PAY_FEES: flatbuffers::VOffsetT = 8;
        pub const VT_USE_CHANGE: flatbuffers::VOffsetT = 10;
        pub const VT_HEIGHT: flatbuffers::VOffsetT = 12;
        pub const VT_EXPIRATION: flatbuffers::VOffsetT = 14;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            PaymentRequest { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<
            'bldr: 'args,
            'args: 'mut_bldr,
            'mut_bldr,
            A: flatbuffers::Allocator + 'bldr,
        >(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
            args: &'args PaymentRequestArgs<'args>,
        ) -> flatbuffers::WIPOffset<PaymentRequest<'bldr>> {
            let mut builder = PaymentRequestBuilder::new(_fbb);
            builder.add_expiration(args.expiration);
            builder.add_height(args.height);
            if let Some(x) = args.recipients {
                builder.add_recipients(x);
            }
            builder.add_use_change(args.use_change);
            builder.add_sender_pay_fees(args.sender_pay_fees);
            builder.add_src_pools(args.src_pools);
            builder.finish()
        }

        pub fn unpack(&self) -> PaymentRequestT {
            let recipients = self
                .recipients()
                .map(|x| x.iter().map(|t| t.unpack()).collect());
            let src_pools = self.src_pools();
            let sender_pay_fees = self.sender_pay_fees();
            let use_change = self.use_change();
            let height = self.height();
            let expiration = self.expiration();
            PaymentRequestT {
                recipients,
                src_pools,
                sender_pay_fees,
                use_change,
                height,
                expiration,
            }
        }

        #[inline]
        pub fn recipients(
            &self,
        ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Recipient<'a>>>> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab.get::<flatbuffers::ForwardsUOffset<
                    flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Recipient>>,
                >>(PaymentRequest::VT_RECIPIENTS, None)
            }
        }
        #[inline]
        pub fn src_pools(&self) -> u8 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<u8>(PaymentRequest::VT_SRC_POOLS, Some(0))
                    .unwrap()
            }
        }
        #[inline]
        pub fn sender_pay_fees(&self) -> bool {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<bool>(PaymentRequest::VT_SENDER_PAY_FEES, Some(false))
                    .unwrap()
            }
        }
        #[inline]
        pub fn use_change(&self) -> bool {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<bool>(PaymentRequest::VT_USE_CHANGE, Some(false))
                    .unwrap()
            }
        }
        #[inline]
        pub fn height(&self) -> u32 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<u32>(PaymentRequest::VT_HEIGHT, Some(0))
                    .unwrap()
            }
        }
        #[inline]
        pub fn expiration(&self) -> u32 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<u32>(PaymentRequest::VT_EXPIRATION, Some(0))
                    .unwrap()
            }
        }
    }

    impl flatbuffers::Verifiable for PaymentRequest<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<flatbuffers::ForwardsUOffset<
                    flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<Recipient>>,
                >>("recipients", Self::VT_RECIPIENTS, false)?
                .visit_field::<u8>("src_pools", Self::VT_SRC_POOLS, false)?
                .visit_field::<bool>("sender_pay_fees", Self::VT_SENDER_PAY_FEES, false)?
                .visit_field::<bool>("use_change", Self::VT_USE_CHANGE, false)?
                .visit_field::<u32>("height", Self::VT_HEIGHT, false)?
                .visit_field::<u32>("expiration", Self::VT_EXPIRATION, false)?
                .finish();
            Ok(())
        }
    }
    pub struct PaymentRequestArgs<'a> {
        pub recipients: Option<
            flatbuffers::WIPOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Recipient<'a>>>,
            >,
        >,
        pub src_pools: u8,
        pub sender_pay_fees: bool,
        pub use_change: bool,
        pub height: u32,
        pub expiration: u32,
    }
    impl<'a> Default for PaymentRequestArgs<'a> {
        #[inline]
        fn default() -> Self {
            PaymentRequestArgs {
                recipients: None,
                src_pools: 0,
                sender_pay_fees: false,
                use_change: false,
                height: 0,
                expiration: 0,
            }
        }
    }

    pub struct PaymentRequestBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> PaymentRequestBuilder<'a, 'b, A> {
        #[inline]
        pub fn add_recipients(
            &mut self,
            recipients: flatbuffers::WIPOffset<
                flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<Recipient<'b>>>,
            >,
        ) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                PaymentRequest::VT_RECIPIENTS,
                recipients,
            );
        }
        #[inline]
        pub fn add_src_pools(&mut self, src_pools: u8) {
            self.fbb_
                .push_slot::<u8>(PaymentRequest::VT_SRC_POOLS, src_pools, 0);
        }
        #[inline]
        pub fn add_sender_pay_fees(&mut self, sender_pay_fees: bool) {
            self.fbb_
                .push_slot::<bool>(PaymentRequest::VT_SENDER_PAY_FEES, sender_pay_fees, false);
        }
        #[inline]
        pub fn add_use_change(&mut self, use_change: bool) {
            self.fbb_
                .push_slot::<bool>(PaymentRequest::VT_USE_CHANGE, use_change, false);
        }
        #[inline]
        pub fn add_height(&mut self, height: u32) {
            self.fbb_
                .push_slot::<u32>(PaymentRequest::VT_HEIGHT, height, 0);
        }
        #[inline]
        pub fn add_expiration(&mut self, expiration: u32) {
            self.fbb_
                .push_slot::<u32>(PaymentRequest::VT_EXPIRATION, expiration, 0);
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        ) -> PaymentRequestBuilder<'a, 'b, A> {
            let start = _fbb.start_table();
            PaymentRequestBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<PaymentRequest<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for PaymentRequest<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("PaymentRequest");
            ds.field("recipients", &self.recipients());
            ds.field("src_pools", &self.src_pools());
            ds.field("sender_pay_fees", &self.sender_pay_fees());
            ds.field("use_change", &self.use_change());
            ds.field("height", &self.height());
            ds.field("expiration", &self.expiration());
            ds.finish()
        }
    }
    #[non_exhaustive]
    #[derive(Serialize, Deserialize, Debug, Clone, PartialEq)]
    pub struct PaymentRequestT {
        pub recipients: Option<Vec<RecipientT>>,
        pub src_pools: u8,
        pub sender_pay_fees: bool,
        pub use_change: bool,
        pub height: u32,
        pub expiration: u32,
    }
    impl Default for PaymentRequestT {
        fn default() -> Self {
            Self {
                recipients: None,
                src_pools: 0,
                sender_pay_fees: false,
                use_change: false,
                height: 0,
                expiration: 0,
            }
        }
    }
    impl PaymentRequestT {
        pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
            &self,
            _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
        ) -> flatbuffers::WIPOffset<PaymentRequest<'b>> {
            let recipients = self.recipients.as_ref().map(|x| {
                let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
                _fbb.create_vector(&w)
            });
            let src_pools = self.src_pools;
            let sender_pay_fees = self.sender_pay_fees;
            let use_change = self.use_change;
            let height = self.height;
            let expiration = self.expiration;
            PaymentRequest::create(
                _fbb,
                &PaymentRequestArgs {
                    recipients,
                    src_pools,
                    sender_pay_fees,
                    use_change,
                    height,
                    expiration,
                },
            )
        }
    }
    pub enum AccountNameOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct AccountName<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for AccountName<'a> {
        type Inner = AccountName<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> AccountName<'a> {
        pub const VT_COIN: flatbuffers::VOffsetT = 4;
        pub const VT_ID: flatbuffers::VOffsetT = 6;
        pub const VT_NAME: flatbuffers::VOffsetT = 8;
        pub const VT_BIRTH: flatbuffers::VOffsetT = 10;
        pub const VT_BALANCE: flatbuffers::VOffsetT = 12;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            AccountName { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<
            'bldr: 'args,
            'args: 'mut_bldr,
            'mut_bldr,
            A: flatbuffers::Allocator + 'bldr,
        >(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
            args: &'args AccountNameArgs<'args>,
        ) -> flatbuffers::WIPOffset<AccountName<'bldr>> {
            let mut builder = AccountNameBuilder::new(_fbb);
            builder.add_balance(args.balance);
            builder.add_birth(args.birth);
            if let Some(x) = args.name {
                builder.add_name(x);
            }
            builder.add_id(args.id);
            builder.add_coin(args.coin);
            builder.finish()
        }

        pub fn unpack(&self) -> AccountNameT {
            let coin = self.coin();
            let id = self.id();
            let name = self.name().map(|x| x.to_string());
            let birth = self.birth();
            let balance = self.balance();
            AccountNameT {
                coin,
                id,
                name,
                birth,
                balance,
            }
        }

        #[inline]
        pub fn coin(&self) -> u8 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe { self._tab.get::<u8>(AccountName::VT_COIN, Some(0)).unwrap() }
        }
        #[inline]
        pub fn id(&self) -> u32 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe { self._tab.get::<u32>(AccountName::VT_ID, Some(0)).unwrap() }
        }
        #[inline]
        pub fn name(&self) -> Option<&'a str> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<&str>>(AccountName::VT_NAME, None)
            }
        }
        #[inline]
        pub fn birth(&self) -> u32 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<u32>(AccountName::VT_BIRTH, Some(0))
                    .unwrap()
            }
        }
        #[inline]
        pub fn balance(&self) -> u64 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<u64>(AccountName::VT_BALANCE, Some(0))
                    .unwrap()
            }
        }
    }

    impl flatbuffers::Verifiable for AccountName<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<u8>("coin", Self::VT_COIN, false)?
                .visit_field::<u32>("id", Self::VT_ID, false)?
                .visit_field::<flatbuffers::ForwardsUOffset<&str>>("name", Self::VT_NAME, false)?
                .visit_field::<u32>("birth", Self::VT_BIRTH, false)?
                .visit_field::<u64>("balance", Self::VT_BALANCE, false)?
                .finish();
            Ok(())
        }
    }
    pub struct AccountNameArgs<'a> {
        pub coin: u8,
        pub id: u32,
        pub name: Option<flatbuffers::WIPOffset<&'a str>>,
        pub birth: u32,
        pub balance: u64,
    }
    impl<'a> Default for AccountNameArgs<'a> {
        #[inline]
        fn default() -> Self {
            AccountNameArgs {
                coin: 0,
                id: 0,
                name: None,
                birth: 0,
                balance: 0,
            }
        }
    }

    pub struct AccountNameBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> AccountNameBuilder<'a, 'b, A> {
        #[inline]
        pub fn add_coin(&mut self, coin: u8) {
            self.fbb_.push_slot::<u8>(AccountName::VT_COIN, coin, 0);
        }
        #[inline]
        pub fn add_id(&mut self, id: u32) {
            self.fbb_.push_slot::<u32>(AccountName::VT_ID, id, 0);
        }
        #[inline]
        pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(AccountName::VT_NAME, name);
        }
        #[inline]
        pub fn add_birth(&mut self, birth: u32) {
            self.fbb_.push_slot::<u32>(AccountName::VT_BIRTH, birth, 0);
        }
        #[inline]
        pub fn add_balance(&mut self, balance: u64) {
            self.fbb_
                .push_slot::<u64>(AccountName::VT_BALANCE, balance, 0);
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        ) -> AccountNameBuilder<'a, 'b, A> {
            let start = _fbb.start_table();
            AccountNameBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<AccountName<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for AccountName<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("AccountName");
            ds.field("coin", &self.coin());
            ds.field("id", &self.id());
            ds.field("name", &self.name());
            ds.field("birth", &self.birth());
            ds.field("balance", &self.balance());
            ds.finish()
        }
    }
    #[non_exhaustive]
    #[derive(Serialize, Deserialize, Debug, Clone, PartialEq)]
    pub struct AccountNameT {
        pub coin: u8,
        pub id: u32,
        pub name: Option<String>,
        pub birth: u32,
        pub balance: u64,
    }
    impl Default for AccountNameT {
        fn default() -> Self {
            Self {
                coin: 0,
                id: 0,
                name: None,
                birth: 0,
                balance: 0,
            }
        }
    }
    impl AccountNameT {
        pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
            &self,
            _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
        ) -> flatbuffers::WIPOffset<AccountName<'b>> {
            let coin = self.coin;
            let id = self.id;
            let name = self.name.as_ref().map(|x| _fbb.create_string(x));
            let birth = self.birth;
            let balance = self.balance;
            AccountName::create(
                _fbb,
                &AccountNameArgs {
                    coin,
                    id,
                    name,
                    birth,
                    balance,
                },
            )
        }
    }
    pub enum ContactCardOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct ContactCard<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for ContactCard<'a> {
        type Inner = ContactCard<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> ContactCard<'a> {
        pub const VT_ID: flatbuffers::VOffsetT = 4;
        pub const VT_ACCOUNT: flatbuffers::VOffsetT = 6;
        pub const VT_NAME: flatbuffers::VOffsetT = 8;
        pub const VT_ADDRESS: flatbuffers::VOffsetT = 10;
        pub const VT_SAVED: flatbuffers::VOffsetT = 12;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            ContactCard { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<
            'bldr: 'args,
            'args: 'mut_bldr,
            'mut_bldr,
            A: flatbuffers::Allocator + 'bldr,
        >(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
            args: &'args ContactCardArgs<'args>,
        ) -> flatbuffers::WIPOffset<ContactCard<'bldr>> {
            let mut builder = ContactCardBuilder::new(_fbb);
            if let Some(x) = args.address {
                builder.add_address(x);
            }
            if let Some(x) = args.name {
                builder.add_name(x);
            }
            builder.add_account(args.account);
            builder.add_id(args.id);
            builder.add_saved(args.saved);
            builder.finish()
        }

        pub fn unpack(&self) -> ContactCardT {
            let id = self.id();
            let account = self.account();
            let name = self.name().map(|x| x.to_string());
            let address = self.address().map(|x| x.to_string());
            let saved = self.saved();
            ContactCardT {
                id,
                account,
                name,
                address,
                saved,
            }
        }

        #[inline]
        pub fn id(&self) -> u32 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe { self._tab.get::<u32>(ContactCard::VT_ID, Some(0)).unwrap() }
        }
        #[inline]
        pub fn account(&self) -> u32 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<u32>(ContactCard::VT_ACCOUNT, Some(0))
                    .unwrap()
            }
        }
        #[inline]
        pub fn name(&self) -> Option<&'a str> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<&str>>(ContactCard::VT_NAME, None)
            }
        }
        #[inline]
        pub fn address(&self) -> Option<&'a str> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<&str>>(ContactCard::VT_ADDRESS, None)
            }
        }
        #[inline]
        pub fn saved(&self) -> bool {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<bool>(ContactCard::VT_SAVED, Some(false))
                    .unwrap()
            }
        }
    }

    impl flatbuffers::Verifiable for ContactCard<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<u32>("id", Self::VT_ID, false)?
                .visit_field::<u32>("account", Self::VT_ACCOUNT, false)?
                .visit_field::<flatbuffers::ForwardsUOffset<&str>>("name", Self::VT_NAME, false)?
                .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                    "address",
                    Self::VT_ADDRESS,
                    false,
                )?
                .visit_field::<bool>("saved", Self::VT_SAVED, false)?
                .finish();
            Ok(())
        }
    }
    pub struct ContactCardArgs<'a> {
        pub id: u32,
        pub account: u32,
        pub name: Option<flatbuffers::WIPOffset<&'a str>>,
        pub address: Option<flatbuffers::WIPOffset<&'a str>>,
        pub saved: bool,
    }
    impl<'a> Default for ContactCardArgs<'a> {
        #[inline]
        fn default() -> Self {
            ContactCardArgs {
                id: 0,
                account: 0,
                name: None,
                address: None,
                saved: false,
            }
        }
    }

    pub struct ContactCardBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> ContactCardBuilder<'a, 'b, A> {
        #[inline]
        pub fn add_id(&mut self, id: u32) {
            self.fbb_.push_slot::<u32>(ContactCard::VT_ID, id, 0);
        }
        #[inline]
        pub fn add_account(&mut self, account: u32) {
            self.fbb_
                .push_slot::<u32>(ContactCard::VT_ACCOUNT, account, 0);
        }
        #[inline]
        pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(ContactCard::VT_NAME, name);
        }
        #[inline]
        pub fn add_address(&mut self, address: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(ContactCard::VT_ADDRESS, address);
        }
        #[inline]
        pub fn add_saved(&mut self, saved: bool) {
            self.fbb_
                .push_slot::<bool>(ContactCard::VT_SAVED, saved, false);
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        ) -> ContactCardBuilder<'a, 'b, A> {
            let start = _fbb.start_table();
            ContactCardBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<ContactCard<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for ContactCard<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("ContactCard");
            ds.field("id", &self.id());
            ds.field("account", &self.account());
            ds.field("name", &self.name());
            ds.field("address", &self.address());
            ds.field("saved", &self.saved());
            ds.finish()
        }
    }
    #[non_exhaustive]
    #[derive(Serialize, Deserialize, Debug, Clone, PartialEq)]
    pub struct ContactCardT {
        pub id: u32,
        pub account: u32,
        pub name: Option<String>,
        pub address: Option<String>,
        pub saved: bool,
    }
    impl Default for ContactCardT {
        fn default() -> Self {
            Self {
                id: 0,
                account: 0,
                name: None,
                address: None,
                saved: false,
            }
        }
    }
    impl ContactCardT {
        pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
            &self,
            _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
        ) -> flatbuffers::WIPOffset<ContactCard<'b>> {
            let id = self.id;
            let account = self.account;
            let name = self.name.as_ref().map(|x| _fbb.create_string(x));
            let address = self.address.as_ref().map(|x| _fbb.create_string(x));
            let saved = self.saved;
            ContactCard::create(
                _fbb,
                &ContactCardArgs {
                    id,
                    account,
                    name,
                    address,
                    saved,
                },
            )
        }
    }
    pub enum TransactionRecipientOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct TransactionRecipient<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for TransactionRecipient<'a> {
        type Inner = TransactionRecipient<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> TransactionRecipient<'a> {
        pub const VT_ADDRESS: flatbuffers::VOffsetT = 4;
        pub const VT_AMOUNT: flatbuffers::VOffsetT = 6;
        pub const VT_CHANGE: flatbuffers::VOffsetT = 8;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            TransactionRecipient { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<
            'bldr: 'args,
            'args: 'mut_bldr,
            'mut_bldr,
            A: flatbuffers::Allocator + 'bldr,
        >(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
            args: &'args TransactionRecipientArgs<'args>,
        ) -> flatbuffers::WIPOffset<TransactionRecipient<'bldr>> {
            let mut builder = TransactionRecipientBuilder::new(_fbb);
            builder.add_amount(args.amount);
            if let Some(x) = args.address {
                builder.add_address(x);
            }
            builder.add_change(args.change);
            builder.finish()
        }

        pub fn unpack(&self) -> TransactionRecipientT {
            let address = self.address().map(|x| x.to_string());
            let amount = self.amount();
            let change = self.change();
            TransactionRecipientT {
                address,
                amount,
                change,
            }
        }

        #[inline]
        pub fn address(&self) -> Option<&'a str> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                    TransactionRecipient::VT_ADDRESS,
                    None,
                )
            }
        }
        #[inline]
        pub fn amount(&self) -> u64 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<u64>(TransactionRecipient::VT_AMOUNT, Some(0))
                    .unwrap()
            }
        }
        #[inline]
        pub fn change(&self) -> bool {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<bool>(TransactionRecipient::VT_CHANGE, Some(false))
                    .unwrap()
            }
        }
    }

    impl flatbuffers::Verifiable for TransactionRecipient<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                    "address",
                    Self::VT_ADDRESS,
                    false,
                )?
                .visit_field::<u64>("amount", Self::VT_AMOUNT, false)?
                .visit_field::<bool>("change", Self::VT_CHANGE, false)?
                .finish();
            Ok(())
        }
    }
    pub struct TransactionRecipientArgs<'a> {
        pub address: Option<flatbuffers::WIPOffset<&'a str>>,
        pub amount: u64,
        pub change: bool,
    }
    impl<'a> Default for TransactionRecipientArgs<'a> {
        #[inline]
        fn default() -> Self {
            TransactionRecipientArgs {
                address: None,
                amount: 0,
                change: false,
            }
        }
    }

    pub struct TransactionRecipientBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> TransactionRecipientBuilder<'a, 'b, A> {
        #[inline]
        pub fn add_address(&mut self, address: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                TransactionRecipient::VT_ADDRESS,
                address,
            );
        }
        #[inline]
        pub fn add_amount(&mut self, amount: u64) {
            self.fbb_
                .push_slot::<u64>(TransactionRecipient::VT_AMOUNT, amount, 0);
        }
        #[inline]
        pub fn add_change(&mut self, change: bool) {
            self.fbb_
                .push_slot::<bool>(TransactionRecipient::VT_CHANGE, change, false);
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        ) -> TransactionRecipientBuilder<'a, 'b, A> {
            let start = _fbb.start_table();
            TransactionRecipientBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<TransactionRecipient<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for TransactionRecipient<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("TransactionRecipient");
            ds.field("address", &self.address());
            ds.field("amount", &self.amount());
            ds.field("change", &self.change());
            ds.finish()
        }
    }
    #[non_exhaustive]
    #[derive(Serialize, Deserialize, Debug, Clone, PartialEq)]
    pub struct TransactionRecipientT {
        pub address: Option<String>,
        pub amount: u64,
        pub change: bool,
    }
    impl Default for TransactionRecipientT {
        fn default() -> Self {
            Self {
                address: None,
                amount: 0,
                change: false,
            }
        }
    }
    impl TransactionRecipientT {
        pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
            &self,
            _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
        ) -> flatbuffers::WIPOffset<TransactionRecipient<'b>> {
            let address = self.address.as_ref().map(|x| _fbb.create_string(x));
            let amount = self.amount;
            let change = self.change;
            TransactionRecipient::create(
                _fbb,
                &TransactionRecipientArgs {
                    address,
                    amount,
                    change,
                },
            )
        }
    }
    pub enum TransactionSummaryOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct TransactionSummary<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for TransactionSummary<'a> {
        type Inner = TransactionSummary<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> TransactionSummary<'a> {
        pub const VT_HEIGHT: flatbuffers::VOffsetT = 4;
        pub const VT_RECIPIENTS: flatbuffers::VOffsetT = 6;
        pub const VT_TRANSPARENT_INS: flatbuffers::VOffsetT = 8;
        pub const VT_SAPLING_NET: flatbuffers::VOffsetT = 10;
        pub const VT_ORCHARD_NET: flatbuffers::VOffsetT = 12;
        pub const VT_FEE: flatbuffers::VOffsetT = 14;
        pub const VT_PRIVACY_LEVEL: flatbuffers::VOffsetT = 16;
        pub const VT_NUM_INPUTS: flatbuffers::VOffsetT = 18;
        pub const VT_NUM_OUTPUTS: flatbuffers::VOffsetT = 20;
        pub const VT_DATA: flatbuffers::VOffsetT = 22;
        pub const VT_REDIRECT: flatbuffers::VOffsetT = 24;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            TransactionSummary { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<
            'bldr: 'args,
            'args: 'mut_bldr,
            'mut_bldr,
            A: flatbuffers::Allocator + 'bldr,
        >(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
            args: &'args TransactionSummaryArgs<'args>,
        ) -> flatbuffers::WIPOffset<TransactionSummary<'bldr>> {
            let mut builder = TransactionSummaryBuilder::new(_fbb);
            builder.add_fee(args.fee);
            builder.add_orchard_net(args.orchard_net);
            builder.add_sapling_net(args.sapling_net);
            builder.add_transparent_ins(args.transparent_ins);
            if let Some(x) = args.redirect {
                builder.add_redirect(x);
            }
            if let Some(x) = args.data {
                builder.add_data(x);
            }
            if let Some(x) = args.num_outputs {
                builder.add_num_outputs(x);
            }
            if let Some(x) = args.num_inputs {
                builder.add_num_inputs(x);
            }
            if let Some(x) = args.recipients {
                builder.add_recipients(x);
            }
            builder.add_height(args.height);
            builder.add_privacy_level(args.privacy_level);
            builder.finish()
        }

        pub fn unpack(&self) -> TransactionSummaryT {
            let height = self.height();
            let recipients = self
                .recipients()
                .map(|x| x.iter().map(|t| t.unpack()).collect());
            let transparent_ins = self.transparent_ins();
            let sapling_net = self.sapling_net();
            let orchard_net = self.orchard_net();
            let fee = self.fee();
            let privacy_level = self.privacy_level();
            let num_inputs = self.num_inputs().map(|x| x.into_iter().collect());
            let num_outputs = self.num_outputs().map(|x| x.into_iter().collect());
            let data = self.data().map(|x| x.into_iter().collect());
            let redirect = self.redirect().map(|x| x.to_string());
            TransactionSummaryT {
                height,
                recipients,
                transparent_ins,
                sapling_net,
                orchard_net,
                fee,
                privacy_level,
                num_inputs,
                num_outputs,
                data,
                redirect,
            }
        }

        #[inline]
        pub fn height(&self) -> u32 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<u32>(TransactionSummary::VT_HEIGHT, Some(0))
                    .unwrap()
            }
        }
        #[inline]
        pub fn recipients(
            &self,
        ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<TransactionRecipient<'a>>>>
        {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab.get::<flatbuffers::ForwardsUOffset<
                    flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<TransactionRecipient>>,
                >>(TransactionSummary::VT_RECIPIENTS, None)
            }
        }
        #[inline]
        pub fn transparent_ins(&self) -> u64 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<u64>(TransactionSummary::VT_TRANSPARENT_INS, Some(0))
                    .unwrap()
            }
        }
        #[inline]
        pub fn sapling_net(&self) -> i64 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<i64>(TransactionSummary::VT_SAPLING_NET, Some(0))
                    .unwrap()
            }
        }
        #[inline]
        pub fn orchard_net(&self) -> i64 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<i64>(TransactionSummary::VT_ORCHARD_NET, Some(0))
                    .unwrap()
            }
        }
        #[inline]
        pub fn fee(&self) -> u64 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<u64>(TransactionSummary::VT_FEE, Some(0))
                    .unwrap()
            }
        }
        #[inline]
        pub fn privacy_level(&self) -> u8 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<u8>(TransactionSummary::VT_PRIVACY_LEVEL, Some(0))
                    .unwrap()
            }
        }
        #[inline]
        pub fn num_inputs(&self) -> Option<flatbuffers::Vector<'a, u8>> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(
                        TransactionSummary::VT_NUM_INPUTS,
                        None,
                    )
            }
        }
        #[inline]
        pub fn num_outputs(&self) -> Option<flatbuffers::Vector<'a, u8>> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(
                        TransactionSummary::VT_NUM_OUTPUTS,
                        None,
                    )
            }
        }
        #[inline]
        pub fn data(&self) -> Option<flatbuffers::Vector<'a, u8>> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(
                        TransactionSummary::VT_DATA,
                        None,
                    )
            }
        }
        #[inline]
        pub fn redirect(&self) -> Option<&'a str> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                    TransactionSummary::VT_REDIRECT,
                    None,
                )
            }
        }
    }

    impl flatbuffers::Verifiable for TransactionSummary<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<u32>("height", Self::VT_HEIGHT, false)?
                .visit_field::<flatbuffers::ForwardsUOffset<
                    flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<TransactionRecipient>>,
                >>("recipients", Self::VT_RECIPIENTS, false)?
                .visit_field::<u64>("transparent_ins", Self::VT_TRANSPARENT_INS, false)?
                .visit_field::<i64>("sapling_net", Self::VT_SAPLING_NET, false)?
                .visit_field::<i64>("orchard_net", Self::VT_ORCHARD_NET, false)?
                .visit_field::<u64>("fee", Self::VT_FEE, false)?
                .visit_field::<u8>("privacy_level", Self::VT_PRIVACY_LEVEL, false)?
                .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>(
                    "num_inputs",
                    Self::VT_NUM_INPUTS,
                    false,
                )?
                .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>(
                    "num_outputs",
                    Self::VT_NUM_OUTPUTS,
                    false,
                )?
                .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>(
                    "data",
                    Self::VT_DATA,
                    false,
                )?
                .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                    "redirect",
                    Self::VT_REDIRECT,
                    false,
                )?
                .finish();
            Ok(())
        }
    }
    pub struct TransactionSummaryArgs<'a> {
        pub height: u32,
        pub recipients: Option<
            flatbuffers::WIPOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<TransactionRecipient<'a>>>,
            >,
        >,
        pub transparent_ins: u64,
        pub sapling_net: i64,
        pub orchard_net: i64,
        pub fee: u64,
        pub privacy_level: u8,
        pub num_inputs: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
        pub num_outputs: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
        pub data: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
        pub redirect: Option<flatbuffers::WIPOffset<&'a str>>,
    }
    impl<'a> Default for TransactionSummaryArgs<'a> {
        #[inline]
        fn default() -> Self {
            TransactionSummaryArgs {
                height: 0,
                recipients: None,
                transparent_ins: 0,
                sapling_net: 0,
                orchard_net: 0,
                fee: 0,
                privacy_level: 0,
                num_inputs: None,
                num_outputs: None,
                data: None,
                redirect: None,
            }
        }
    }

    pub struct TransactionSummaryBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> TransactionSummaryBuilder<'a, 'b, A> {
        #[inline]
        pub fn add_height(&mut self, height: u32) {
            self.fbb_
                .push_slot::<u32>(TransactionSummary::VT_HEIGHT, height, 0);
        }
        #[inline]
        pub fn add_recipients(
            &mut self,
            recipients: flatbuffers::WIPOffset<
                flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<TransactionRecipient<'b>>>,
            >,
        ) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                TransactionSummary::VT_RECIPIENTS,
                recipients,
            );
        }
        #[inline]
        pub fn add_transparent_ins(&mut self, transparent_ins: u64) {
            self.fbb_
                .push_slot::<u64>(TransactionSummary::VT_TRANSPARENT_INS, transparent_ins, 0);
        }
        #[inline]
        pub fn add_sapling_net(&mut self, sapling_net: i64) {
            self.fbb_
                .push_slot::<i64>(TransactionSummary::VT_SAPLING_NET, sapling_net, 0);
        }
        #[inline]
        pub fn add_orchard_net(&mut self, orchard_net: i64) {
            self.fbb_
                .push_slot::<i64>(TransactionSummary::VT_ORCHARD_NET, orchard_net, 0);
        }
        #[inline]
        pub fn add_fee(&mut self, fee: u64) {
            self.fbb_
                .push_slot::<u64>(TransactionSummary::VT_FEE, fee, 0);
        }
        #[inline]
        pub fn add_privacy_level(&mut self, privacy_level: u8) {
            self.fbb_
                .push_slot::<u8>(TransactionSummary::VT_PRIVACY_LEVEL, privacy_level, 0);
        }
        #[inline]
        pub fn add_num_inputs(
            &mut self,
            num_inputs: flatbuffers::WIPOffset<flatbuffers::Vector<'b, u8>>,
        ) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                TransactionSummary::VT_NUM_INPUTS,
                num_inputs,
            );
        }
        #[inline]
        pub fn add_num_outputs(
            &mut self,
            num_outputs: flatbuffers::WIPOffset<flatbuffers::Vector<'b, u8>>,
        ) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                TransactionSummary::VT_NUM_OUTPUTS,
                num_outputs,
            );
        }
        #[inline]
        pub fn add_data(&mut self, data: flatbuffers::WIPOffset<flatbuffers::Vector<'b, u8>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(TransactionSummary::VT_DATA, data);
        }
        #[inline]
        pub fn add_redirect(&mut self, redirect: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                TransactionSummary::VT_REDIRECT,
                redirect,
            );
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        ) -> TransactionSummaryBuilder<'a, 'b, A> {
            let start = _fbb.start_table();
            TransactionSummaryBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<TransactionSummary<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for TransactionSummary<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("TransactionSummary");
            ds.field("height", &self.height());
            ds.field("recipients", &self.recipients());
            ds.field("transparent_ins", &self.transparent_ins());
            ds.field("sapling_net", &self.sapling_net());
            ds.field("orchard_net", &self.orchard_net());
            ds.field("fee", &self.fee());
            ds.field("privacy_level", &self.privacy_level());
            ds.field("num_inputs", &self.num_inputs());
            ds.field("num_outputs", &self.num_outputs());
            ds.field("data", &self.data());
            ds.field("redirect", &self.redirect());
            ds.finish()
        }
    }
    #[non_exhaustive]
    #[derive(Serialize, Deserialize, Debug, Clone, PartialEq)]
    pub struct TransactionSummaryT {
        pub height: u32,
        pub recipients: Option<Vec<TransactionRecipientT>>,
        pub transparent_ins: u64,
        pub sapling_net: i64,
        pub orchard_net: i64,
        pub fee: u64,
        pub privacy_level: u8,
        pub num_inputs: Option<Vec<u8>>,
        pub num_outputs: Option<Vec<u8>>,
        pub data: Option<Vec<u8>>,
        pub redirect: Option<String>,
    }
    impl Default for TransactionSummaryT {
        fn default() -> Self {
            Self {
                height: 0,
                recipients: None,
                transparent_ins: 0,
                sapling_net: 0,
                orchard_net: 0,
                fee: 0,
                privacy_level: 0,
                num_inputs: None,
                num_outputs: None,
                data: None,
                redirect: None,
            }
        }
    }
    impl TransactionSummaryT {
        pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
            &self,
            _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
        ) -> flatbuffers::WIPOffset<TransactionSummary<'b>> {
            let height = self.height;
            let recipients = self.recipients.as_ref().map(|x| {
                let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
                _fbb.create_vector(&w)
            });
            let transparent_ins = self.transparent_ins;
            let sapling_net = self.sapling_net;
            let orchard_net = self.orchard_net;
            let fee = self.fee;
            let privacy_level = self.privacy_level;
            let num_inputs = self.num_inputs.as_ref().map(|x| _fbb.create_vector(x));
            let num_outputs = self.num_outputs.as_ref().map(|x| _fbb.create_vector(x));
            let data = self.data.as_ref().map(|x| _fbb.create_vector(x));
            let redirect = self.redirect.as_ref().map(|x| _fbb.create_string(x));
            TransactionSummary::create(
                _fbb,
                &TransactionSummaryArgs {
                    height,
                    recipients,
                    transparent_ins,
                    sapling_net,
                    orchard_net,
                    fee,
                    privacy_level,
                    num_inputs,
                    num_outputs,
                    data,
                    redirect,
                },
            )
        }
    }
    pub enum AGEKeysOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct AGEKeys<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for AGEKeys<'a> {
        type Inner = AGEKeys<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> AGEKeys<'a> {
        pub const VT_PUBLIC_KEY: flatbuffers::VOffsetT = 4;
        pub const VT_SECRET_KEY: flatbuffers::VOffsetT = 6;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            AGEKeys { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<
            'bldr: 'args,
            'args: 'mut_bldr,
            'mut_bldr,
            A: flatbuffers::Allocator + 'bldr,
        >(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
            args: &'args AGEKeysArgs<'args>,
        ) -> flatbuffers::WIPOffset<AGEKeys<'bldr>> {
            let mut builder = AGEKeysBuilder::new(_fbb);
            if let Some(x) = args.secret_key {
                builder.add_secret_key(x);
            }
            if let Some(x) = args.public_key {
                builder.add_public_key(x);
            }
            builder.finish()
        }

        pub fn unpack(&self) -> AGEKeysT {
            let public_key = self.public_key().map(|x| x.to_string());
            let secret_key = self.secret_key().map(|x| x.to_string());
            AGEKeysT {
                public_key,
                secret_key,
            }
        }

        #[inline]
        pub fn public_key(&self) -> Option<&'a str> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<&str>>(AGEKeys::VT_PUBLIC_KEY, None)
            }
        }
        #[inline]
        pub fn secret_key(&self) -> Option<&'a str> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<&str>>(AGEKeys::VT_SECRET_KEY, None)
            }
        }
    }

    impl flatbuffers::Verifiable for AGEKeys<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                    "public_key",
                    Self::VT_PUBLIC_KEY,
                    false,
                )?
                .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                    "secret_key",
                    Self::VT_SECRET_KEY,
                    false,
                )?
                .finish();
            Ok(())
        }
    }
    pub struct AGEKeysArgs<'a> {
        pub public_key: Option<flatbuffers::WIPOffset<&'a str>>,
        pub secret_key: Option<flatbuffers::WIPOffset<&'a str>>,
    }
    impl<'a> Default for AGEKeysArgs<'a> {
        #[inline]
        fn default() -> Self {
            AGEKeysArgs {
                public_key: None,
                secret_key: None,
            }
        }
    }

    pub struct AGEKeysBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> AGEKeysBuilder<'a, 'b, A> {
        #[inline]
        pub fn add_public_key(&mut self, public_key: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(AGEKeys::VT_PUBLIC_KEY, public_key);
        }
        #[inline]
        pub fn add_secret_key(&mut self, secret_key: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(AGEKeys::VT_SECRET_KEY, secret_key);
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        ) -> AGEKeysBuilder<'a, 'b, A> {
            let start = _fbb.start_table();
            AGEKeysBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<AGEKeys<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for AGEKeys<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("AGEKeys");
            ds.field("public_key", &self.public_key());
            ds.field("secret_key", &self.secret_key());
            ds.finish()
        }
    }
    #[non_exhaustive]
    #[derive(Serialize, Deserialize, Debug, Clone, PartialEq)]
    pub struct AGEKeysT {
        pub public_key: Option<String>,
        pub secret_key: Option<String>,
    }
    impl Default for AGEKeysT {
        fn default() -> Self {
            Self {
                public_key: None,
                secret_key: None,
            }
        }
    }
    impl AGEKeysT {
        pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
            &self,
            _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
        ) -> flatbuffers::WIPOffset<AGEKeys<'b>> {
            let public_key = self.public_key.as_ref().map(|x| _fbb.create_string(x));
            let secret_key = self.secret_key.as_ref().map(|x| _fbb.create_string(x));
            AGEKeys::create(
                _fbb,
                &AGEKeysArgs {
                    public_key,
                    secret_key,
                },
            )
        }
    }
    pub enum BalanceOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct Balance<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for Balance<'a> {
        type Inner = Balance<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> Balance<'a> {
        pub const VT_TRANSPARENT: flatbuffers::VOffsetT = 4;
        pub const VT_SAPLING: flatbuffers::VOffsetT = 6;
        pub const VT_ORCHARD: flatbuffers::VOffsetT = 8;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            Balance { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<
            'bldr: 'args,
            'args: 'mut_bldr,
            'mut_bldr,
            A: flatbuffers::Allocator + 'bldr,
        >(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
            args: &'args BalanceArgs,
        ) -> flatbuffers::WIPOffset<Balance<'bldr>> {
            let mut builder = BalanceBuilder::new(_fbb);
            builder.add_orchard(args.orchard);
            builder.add_sapling(args.sapling);
            builder.add_transparent(args.transparent);
            builder.finish()
        }

        pub fn unpack(&self) -> BalanceT {
            let transparent = self.transparent();
            let sapling = self.sapling();
            let orchard = self.orchard();
            BalanceT {
                transparent,
                sapling,
                orchard,
            }
        }

        #[inline]
        pub fn transparent(&self) -> u64 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<u64>(Balance::VT_TRANSPARENT, Some(0))
                    .unwrap()
            }
        }
        #[inline]
        pub fn sapling(&self) -> u64 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe { self._tab.get::<u64>(Balance::VT_SAPLING, Some(0)).unwrap() }
        }
        #[inline]
        pub fn orchard(&self) -> u64 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe { self._tab.get::<u64>(Balance::VT_ORCHARD, Some(0)).unwrap() }
        }
    }

    impl flatbuffers::Verifiable for Balance<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<u64>("transparent", Self::VT_TRANSPARENT, false)?
                .visit_field::<u64>("sapling", Self::VT_SAPLING, false)?
                .visit_field::<u64>("orchard", Self::VT_ORCHARD, false)?
                .finish();
            Ok(())
        }
    }
    pub struct BalanceArgs {
        pub transparent: u64,
        pub sapling: u64,
        pub orchard: u64,
    }
    impl<'a> Default for BalanceArgs {
        #[inline]
        fn default() -> Self {
            BalanceArgs {
                transparent: 0,
                sapling: 0,
                orchard: 0,
            }
        }
    }

    pub struct BalanceBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> BalanceBuilder<'a, 'b, A> {
        #[inline]
        pub fn add_transparent(&mut self, transparent: u64) {
            self.fbb_
                .push_slot::<u64>(Balance::VT_TRANSPARENT, transparent, 0);
        }
        #[inline]
        pub fn add_sapling(&mut self, sapling: u64) {
            self.fbb_.push_slot::<u64>(Balance::VT_SAPLING, sapling, 0);
        }
        #[inline]
        pub fn add_orchard(&mut self, orchard: u64) {
            self.fbb_.push_slot::<u64>(Balance::VT_ORCHARD, orchard, 0);
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        ) -> BalanceBuilder<'a, 'b, A> {
            let start = _fbb.start_table();
            BalanceBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<Balance<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for Balance<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("Balance");
            ds.field("transparent", &self.transparent());
            ds.field("sapling", &self.sapling());
            ds.field("orchard", &self.orchard());
            ds.finish()
        }
    }
    #[non_exhaustive]
    #[derive(Serialize, Deserialize, Debug, Clone, PartialEq)]
    pub struct BalanceT {
        pub transparent: u64,
        pub sapling: u64,
        pub orchard: u64,
    }
    impl Default for BalanceT {
        fn default() -> Self {
            Self {
                transparent: 0,
                sapling: 0,
                orchard: 0,
            }
        }
    }
    impl BalanceT {
        pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
            &self,
            _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
        ) -> flatbuffers::WIPOffset<Balance<'b>> {
            let transparent = self.transparent;
            let sapling = self.sapling;
            let orchard = self.orchard;
            Balance::create(
                _fbb,
                &BalanceArgs {
                    transparent,
                    sapling,
                    orchard,
                },
            )
        }
    }
    pub enum PacketOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct Packet<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for Packet<'a> {
        type Inner = Packet<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> Packet<'a> {
        pub const VT_DATA: flatbuffers::VOffsetT = 4;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            Packet { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<
            'bldr: 'args,
            'args: 'mut_bldr,
            'mut_bldr,
            A: flatbuffers::Allocator + 'bldr,
        >(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
            args: &'args PacketArgs<'args>,
        ) -> flatbuffers::WIPOffset<Packet<'bldr>> {
            let mut builder = PacketBuilder::new(_fbb);
            if let Some(x) = args.data {
                builder.add_data(x);
            }
            builder.finish()
        }

        pub fn unpack(&self) -> PacketT {
            let data = self.data().map(|x| x.into_iter().collect());
            PacketT { data }
        }

        #[inline]
        pub fn data(&self) -> Option<flatbuffers::Vector<'a, u8>> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(
                        Packet::VT_DATA,
                        None,
                    )
            }
        }
    }

    impl flatbuffers::Verifiable for Packet<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>(
                    "data",
                    Self::VT_DATA,
                    false,
                )?
                .finish();
            Ok(())
        }
    }
    pub struct PacketArgs<'a> {
        pub data: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
    }
    impl<'a> Default for PacketArgs<'a> {
        #[inline]
        fn default() -> Self {
            PacketArgs { data: None }
        }
    }

    pub struct PacketBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> PacketBuilder<'a, 'b, A> {
        #[inline]
        pub fn add_data(&mut self, data: flatbuffers::WIPOffset<flatbuffers::Vector<'b, u8>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(Packet::VT_DATA, data);
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        ) -> PacketBuilder<'a, 'b, A> {
            let start = _fbb.start_table();
            PacketBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<Packet<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for Packet<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("Packet");
            ds.field("data", &self.data());
            ds.finish()
        }
    }
    #[non_exhaustive]
    #[derive(Serialize, Deserialize, Debug, Clone, PartialEq)]
    pub struct PacketT {
        pub data: Option<Vec<u8>>,
    }
    impl Default for PacketT {
        fn default() -> Self {
            Self { data: None }
        }
    }
    impl PacketT {
        pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
            &self,
            _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
        ) -> flatbuffers::WIPOffset<Packet<'b>> {
            let data = self.data.as_ref().map(|x| _fbb.create_vector(x));
            Packet::create(_fbb, &PacketArgs { data })
        }
    }
    pub enum PacketsOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct Packets<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for Packets<'a> {
        type Inner = Packets<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> Packets<'a> {
        pub const VT_PACKETS: flatbuffers::VOffsetT = 4;
        pub const VT_LEN: flatbuffers::VOffsetT = 6;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            Packets { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<
            'bldr: 'args,
            'args: 'mut_bldr,
            'mut_bldr,
            A: flatbuffers::Allocator + 'bldr,
        >(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
            args: &'args PacketsArgs<'args>,
        ) -> flatbuffers::WIPOffset<Packets<'bldr>> {
            let mut builder = PacketsBuilder::new(_fbb);
            builder.add_len(args.len);
            if let Some(x) = args.packets {
                builder.add_packets(x);
            }
            builder.finish()
        }

        pub fn unpack(&self) -> PacketsT {
            let packets = self
                .packets()
                .map(|x| x.iter().map(|t| t.unpack()).collect());
            let len = self.len();
            PacketsT { packets, len }
        }

        #[inline]
        pub fn packets(
            &self,
        ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Packet<'a>>>> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab.get::<flatbuffers::ForwardsUOffset<
                    flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Packet>>,
                >>(Packets::VT_PACKETS, None)
            }
        }
        #[inline]
        pub fn len(&self) -> u32 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe { self._tab.get::<u32>(Packets::VT_LEN, Some(0)).unwrap() }
        }
    }

    impl flatbuffers::Verifiable for Packets<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<flatbuffers::ForwardsUOffset<
                    flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<Packet>>,
                >>("packets", Self::VT_PACKETS, false)?
                .visit_field::<u32>("len", Self::VT_LEN, false)?
                .finish();
            Ok(())
        }
    }
    pub struct PacketsArgs<'a> {
        pub packets: Option<
            flatbuffers::WIPOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Packet<'a>>>,
            >,
        >,
        pub len: u32,
    }
    impl<'a> Default for PacketsArgs<'a> {
        #[inline]
        fn default() -> Self {
            PacketsArgs {
                packets: None,
                len: 0,
            }
        }
    }

    pub struct PacketsBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> PacketsBuilder<'a, 'b, A> {
        #[inline]
        pub fn add_packets(
            &mut self,
            packets: flatbuffers::WIPOffset<
                flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<Packet<'b>>>,
            >,
        ) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(Packets::VT_PACKETS, packets);
        }
        #[inline]
        pub fn add_len(&mut self, len: u32) {
            self.fbb_.push_slot::<u32>(Packets::VT_LEN, len, 0);
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        ) -> PacketsBuilder<'a, 'b, A> {
            let start = _fbb.start_table();
            PacketsBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<Packets<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for Packets<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("Packets");
            ds.field("packets", &self.packets());
            ds.field("len", &self.len());
            ds.finish()
        }
    }
    #[non_exhaustive]
    #[derive(Serialize, Deserialize, Debug, Clone, PartialEq)]
    pub struct PacketsT {
        pub packets: Option<Vec<PacketT>>,
        pub len: u32,
    }
    impl Default for PacketsT {
        fn default() -> Self {
            Self {
                packets: None,
                len: 0,
            }
        }
    }
    impl PacketsT {
        pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
            &self,
            _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
        ) -> flatbuffers::WIPOffset<Packets<'b>> {
            let packets = self.packets.as_ref().map(|x| {
                let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
                _fbb.create_vector(&w)
            });
            let len = self.len;
            Packets::create(_fbb, &PacketsArgs { packets, len })
        }
    }
    pub enum CheckpointOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct Checkpoint<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for Checkpoint<'a> {
        type Inner = Checkpoint<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> Checkpoint<'a> {
        pub const VT_HEIGHT: flatbuffers::VOffsetT = 4;
        pub const VT_HASH: flatbuffers::VOffsetT = 6;
        pub const VT_TIMESTAMP: flatbuffers::VOffsetT = 8;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            Checkpoint { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<
            'bldr: 'args,
            'args: 'mut_bldr,
            'mut_bldr,
            A: flatbuffers::Allocator + 'bldr,
        >(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
            args: &'args CheckpointArgs<'args>,
        ) -> flatbuffers::WIPOffset<Checkpoint<'bldr>> {
            let mut builder = CheckpointBuilder::new(_fbb);
            builder.add_timestamp(args.timestamp);
            if let Some(x) = args.hash {
                builder.add_hash(x);
            }
            builder.add_height(args.height);
            builder.finish()
        }

        pub fn unpack(&self) -> CheckpointT {
            let height = self.height();
            let hash = self.hash().map(|x| x.into_iter().collect());
            let timestamp = self.timestamp();
            CheckpointT {
                height,
                hash,
                timestamp,
            }
        }

        #[inline]
        pub fn height(&self) -> u32 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<u32>(Checkpoint::VT_HEIGHT, Some(0))
                    .unwrap()
            }
        }
        #[inline]
        pub fn hash(&self) -> Option<flatbuffers::Vector<'a, u8>> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(
                        Checkpoint::VT_HASH,
                        None,
                    )
            }
        }
        #[inline]
        pub fn timestamp(&self) -> u32 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<u32>(Checkpoint::VT_TIMESTAMP, Some(0))
                    .unwrap()
            }
        }
    }

    impl flatbuffers::Verifiable for Checkpoint<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<u32>("height", Self::VT_HEIGHT, false)?
                .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>(
                    "hash",
                    Self::VT_HASH,
                    false,
                )?
                .visit_field::<u32>("timestamp", Self::VT_TIMESTAMP, false)?
                .finish();
            Ok(())
        }
    }
    pub struct CheckpointArgs<'a> {
        pub height: u32,
        pub hash: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
        pub timestamp: u32,
    }
    impl<'a> Default for CheckpointArgs<'a> {
        #[inline]
        fn default() -> Self {
            CheckpointArgs {
                height: 0,
                hash: None,
                timestamp: 0,
            }
        }
    }

    pub struct CheckpointBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> CheckpointBuilder<'a, 'b, A> {
        #[inline]
        pub fn add_height(&mut self, height: u32) {
            self.fbb_.push_slot::<u32>(Checkpoint::VT_HEIGHT, height, 0);
        }
        #[inline]
        pub fn add_hash(&mut self, hash: flatbuffers::WIPOffset<flatbuffers::Vector<'b, u8>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(Checkpoint::VT_HASH, hash);
        }
        #[inline]
        pub fn add_timestamp(&mut self, timestamp: u32) {
            self.fbb_
                .push_slot::<u32>(Checkpoint::VT_TIMESTAMP, timestamp, 0);
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        ) -> CheckpointBuilder<'a, 'b, A> {
            let start = _fbb.start_table();
            CheckpointBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<Checkpoint<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for Checkpoint<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("Checkpoint");
            ds.field("height", &self.height());
            ds.field("hash", &self.hash());
            ds.field("timestamp", &self.timestamp());
            ds.finish()
        }
    }
    #[non_exhaustive]
    #[derive(Serialize, Deserialize, Debug, Clone, PartialEq)]
    pub struct CheckpointT {
        pub height: u32,
        pub hash: Option<Vec<u8>>,
        pub timestamp: u32,
    }
    impl Default for CheckpointT {
        fn default() -> Self {
            Self {
                height: 0,
                hash: None,
                timestamp: 0,
            }
        }
    }
    impl CheckpointT {
        pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
            &self,
            _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
        ) -> flatbuffers::WIPOffset<Checkpoint<'b>> {
            let height = self.height;
            let hash = self.hash.as_ref().map(|x| _fbb.create_vector(x));
            let timestamp = self.timestamp;
            Checkpoint::create(
                _fbb,
                &CheckpointArgs {
                    height,
                    hash,
                    timestamp,
                },
            )
        }
    }
    pub enum SpendingOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct Spending<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for Spending<'a> {
        type Inner = Spending<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> Spending<'a> {
        pub const VT_RECIPIENT: flatbuffers::VOffsetT = 4;
        pub const VT_AMOUNT: flatbuffers::VOffsetT = 6;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            Spending { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<
            'bldr: 'args,
            'args: 'mut_bldr,
            'mut_bldr,
            A: flatbuffers::Allocator + 'bldr,
        >(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
            args: &'args SpendingArgs<'args>,
        ) -> flatbuffers::WIPOffset<Spending<'bldr>> {
            let mut builder = SpendingBuilder::new(_fbb);
            builder.add_amount(args.amount);
            if let Some(x) = args.recipient {
                builder.add_recipient(x);
            }
            builder.finish()
        }

        pub fn unpack(&self) -> SpendingT {
            let recipient = self.recipient().map(|x| x.to_string());
            let amount = self.amount();
            SpendingT { recipient, amount }
        }

        #[inline]
        pub fn recipient(&self) -> Option<&'a str> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<&str>>(Spending::VT_RECIPIENT, None)
            }
        }
        #[inline]
        pub fn amount(&self) -> u64 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe { self._tab.get::<u64>(Spending::VT_AMOUNT, Some(0)).unwrap() }
        }
    }

    impl flatbuffers::Verifiable for Spending<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                    "recipient",
                    Self::VT_RECIPIENT,
                    false,
                )?
                .visit_field::<u64>("amount", Self::VT_AMOUNT, false)?
                .finish();
            Ok(())
        }
    }
    pub struct SpendingArgs<'a> {
        pub recipient: Option<flatbuffers::WIPOffset<&'a str>>,
        pub amount: u64,
    }
    impl<'a> Default for SpendingArgs<'a> {
        #[inline]
        fn default() -> Self {
            SpendingArgs {
                recipient: None,
                amount: 0,
            }
        }
    }

    pub struct SpendingBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> SpendingBuilder<'a, 'b, A> {
        #[inline]
        pub fn add_recipient(&mut self, recipient: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(Spending::VT_RECIPIENT, recipient);
        }
        #[inline]
        pub fn add_amount(&mut self, amount: u64) {
            self.fbb_.push_slot::<u64>(Spending::VT_AMOUNT, amount, 0);
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        ) -> SpendingBuilder<'a, 'b, A> {
            let start = _fbb.start_table();
            SpendingBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<Spending<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for Spending<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("Spending");
            ds.field("recipient", &self.recipient());
            ds.field("amount", &self.amount());
            ds.finish()
        }
    }
    #[non_exhaustive]
    #[derive(Serialize, Deserialize, Debug, Clone, PartialEq)]
    pub struct SpendingT {
        pub recipient: Option<String>,
        pub amount: u64,
    }
    impl Default for SpendingT {
        fn default() -> Self {
            Self {
                recipient: None,
                amount: 0,
            }
        }
    }
    impl SpendingT {
        pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
            &self,
            _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
        ) -> flatbuffers::WIPOffset<Spending<'b>> {
            let recipient = self.recipient.as_ref().map(|x| _fbb.create_string(x));
            let amount = self.amount;
            Spending::create(_fbb, &SpendingArgs { recipient, amount })
        }
    }
    pub enum ProgressOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct Progress<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for Progress<'a> {
        type Inner = Progress<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> Progress<'a> {
        pub const VT_TRIAL_DECRYPTIONS: flatbuffers::VOffsetT = 4;
        pub const VT_DOWNLOADED: flatbuffers::VOffsetT = 6;
        pub const VT_HEIGHT: flatbuffers::VOffsetT = 8;
        pub const VT_TIMESTAMP: flatbuffers::VOffsetT = 10;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            Progress { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<
            'bldr: 'args,
            'args: 'mut_bldr,
            'mut_bldr,
            A: flatbuffers::Allocator + 'bldr,
        >(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
            args: &'args ProgressArgs,
        ) -> flatbuffers::WIPOffset<Progress<'bldr>> {
            let mut builder = ProgressBuilder::new(_fbb);
            builder.add_downloaded(args.downloaded);
            builder.add_timestamp(args.timestamp);
            builder.add_height(args.height);
            builder.add_trial_decryptions(args.trial_decryptions);
            builder.finish()
        }

        pub fn unpack(&self) -> ProgressT {
            let trial_decryptions = self.trial_decryptions();
            let downloaded = self.downloaded();
            let height = self.height();
            let timestamp = self.timestamp();
            ProgressT {
                trial_decryptions,
                downloaded,
                height,
                timestamp,
            }
        }

        #[inline]
        pub fn trial_decryptions(&self) -> u32 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<u32>(Progress::VT_TRIAL_DECRYPTIONS, Some(0))
                    .unwrap()
            }
        }
        #[inline]
        pub fn downloaded(&self) -> u64 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<u64>(Progress::VT_DOWNLOADED, Some(0))
                    .unwrap()
            }
        }
        #[inline]
        pub fn height(&self) -> u32 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe { self._tab.get::<u32>(Progress::VT_HEIGHT, Some(0)).unwrap() }
        }
        #[inline]
        pub fn timestamp(&self) -> u32 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<u32>(Progress::VT_TIMESTAMP, Some(0))
                    .unwrap()
            }
        }
    }

    impl flatbuffers::Verifiable for Progress<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<u32>("trial_decryptions", Self::VT_TRIAL_DECRYPTIONS, false)?
                .visit_field::<u64>("downloaded", Self::VT_DOWNLOADED, false)?
                .visit_field::<u32>("height", Self::VT_HEIGHT, false)?
                .visit_field::<u32>("timestamp", Self::VT_TIMESTAMP, false)?
                .finish();
            Ok(())
        }
    }
    pub struct ProgressArgs {
        pub trial_decryptions: u32,
        pub downloaded: u64,
        pub height: u32,
        pub timestamp: u32,
    }
    impl<'a> Default for ProgressArgs {
        #[inline]
        fn default() -> Self {
            ProgressArgs {
                trial_decryptions: 0,
                downloaded: 0,
                height: 0,
                timestamp: 0,
            }
        }
    }

    pub struct ProgressBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> ProgressBuilder<'a, 'b, A> {
        #[inline]
        pub fn add_trial_decryptions(&mut self, trial_decryptions: u32) {
            self.fbb_
                .push_slot::<u32>(Progress::VT_TRIAL_DECRYPTIONS, trial_decryptions, 0);
        }
        #[inline]
        pub fn add_downloaded(&mut self, downloaded: u64) {
            self.fbb_
                .push_slot::<u64>(Progress::VT_DOWNLOADED, downloaded, 0);
        }
        #[inline]
        pub fn add_height(&mut self, height: u32) {
            self.fbb_.push_slot::<u32>(Progress::VT_HEIGHT, height, 0);
        }
        #[inline]
        pub fn add_timestamp(&mut self, timestamp: u32) {
            self.fbb_
                .push_slot::<u32>(Progress::VT_TIMESTAMP, timestamp, 0);
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        ) -> ProgressBuilder<'a, 'b, A> {
            let start = _fbb.start_table();
            ProgressBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<Progress<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for Progress<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("Progress");
            ds.field("trial_decryptions", &self.trial_decryptions());
            ds.field("downloaded", &self.downloaded());
            ds.field("height", &self.height());
            ds.field("timestamp", &self.timestamp());
            ds.finish()
        }
    }
    #[non_exhaustive]
    #[derive(Serialize, Deserialize, Debug, Clone, PartialEq)]
    pub struct ProgressT {
        pub trial_decryptions: u32,
        pub downloaded: u64,
        pub height: u32,
        pub timestamp: u32,
    }
    impl Default for ProgressT {
        fn default() -> Self {
            Self {
                trial_decryptions: 0,
                downloaded: 0,
                height: 0,
                timestamp: 0,
            }
        }
    }
    impl ProgressT {
        pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
            &self,
            _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
        ) -> flatbuffers::WIPOffset<Progress<'b>> {
            let trial_decryptions = self.trial_decryptions;
            let downloaded = self.downloaded;
            let height = self.height;
            let timestamp = self.timestamp;
            Progress::create(
                _fbb,
                &ProgressArgs {
                    trial_decryptions,
                    downloaded,
                    height,
                    timestamp,
                },
            )
        }
    }
    pub enum UserMemoOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct UserMemo<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for UserMemo<'a> {
        type Inner = UserMemo<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> UserMemo<'a> {
        pub const VT_REPLY_TO: flatbuffers::VOffsetT = 4;
        pub const VT_SENDER: flatbuffers::VOffsetT = 6;
        pub const VT_RECIPIENT: flatbuffers::VOffsetT = 8;
        pub const VT_BODY: flatbuffers::VOffsetT = 10;
        pub const VT_SUBJECT: flatbuffers::VOffsetT = 12;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            UserMemo { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<
            'bldr: 'args,
            'args: 'mut_bldr,
            'mut_bldr,
            A: flatbuffers::Allocator + 'bldr,
        >(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
            args: &'args UserMemoArgs<'args>,
        ) -> flatbuffers::WIPOffset<UserMemo<'bldr>> {
            let mut builder = UserMemoBuilder::new(_fbb);
            if let Some(x) = args.subject {
                builder.add_subject(x);
            }
            if let Some(x) = args.body {
                builder.add_body(x);
            }
            if let Some(x) = args.recipient {
                builder.add_recipient(x);
            }
            if let Some(x) = args.sender {
                builder.add_sender(x);
            }
            builder.add_reply_to(args.reply_to);
            builder.finish()
        }

        pub fn unpack(&self) -> UserMemoT {
            let reply_to = self.reply_to();
            let sender = self.sender().map(|x| x.to_string());
            let recipient = self.recipient().map(|x| x.to_string());
            let body = self.body().map(|x| x.to_string());
            let subject = self.subject().map(|x| x.to_string());
            UserMemoT {
                reply_to,
                sender,
                recipient,
                body,
                subject,
            }
        }

        #[inline]
        pub fn reply_to(&self) -> bool {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<bool>(UserMemo::VT_REPLY_TO, Some(false))
                    .unwrap()
            }
        }
        #[inline]
        pub fn sender(&self) -> Option<&'a str> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<&str>>(UserMemo::VT_SENDER, None)
            }
        }
        #[inline]
        pub fn recipient(&self) -> Option<&'a str> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<&str>>(UserMemo::VT_RECIPIENT, None)
            }
        }
        #[inline]
        pub fn body(&self) -> Option<&'a str> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<&str>>(UserMemo::VT_BODY, None)
            }
        }
        #[inline]
        pub fn subject(&self) -> Option<&'a str> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<&str>>(UserMemo::VT_SUBJECT, None)
            }
        }
    }

    impl flatbuffers::Verifiable for UserMemo<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<bool>("reply_to", Self::VT_REPLY_TO, false)?
                .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                    "sender",
                    Self::VT_SENDER,
                    false,
                )?
                .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                    "recipient",
                    Self::VT_RECIPIENT,
                    false,
                )?
                .visit_field::<flatbuffers::ForwardsUOffset<&str>>("body", Self::VT_BODY, false)?
                .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                    "subject",
                    Self::VT_SUBJECT,
                    false,
                )?
                .finish();
            Ok(())
        }
    }
    pub struct UserMemoArgs<'a> {
        pub reply_to: bool,
        pub sender: Option<flatbuffers::WIPOffset<&'a str>>,
        pub recipient: Option<flatbuffers::WIPOffset<&'a str>>,
        pub body: Option<flatbuffers::WIPOffset<&'a str>>,
        pub subject: Option<flatbuffers::WIPOffset<&'a str>>,
    }
    impl<'a> Default for UserMemoArgs<'a> {
        #[inline]
        fn default() -> Self {
            UserMemoArgs {
                reply_to: false,
                sender: None,
                recipient: None,
                body: None,
                subject: None,
            }
        }
    }

    pub struct UserMemoBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> UserMemoBuilder<'a, 'b, A> {
        #[inline]
        pub fn add_reply_to(&mut self, reply_to: bool) {
            self.fbb_
                .push_slot::<bool>(UserMemo::VT_REPLY_TO, reply_to, false);
        }
        #[inline]
        pub fn add_sender(&mut self, sender: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(UserMemo::VT_SENDER, sender);
        }
        #[inline]
        pub fn add_recipient(&mut self, recipient: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(UserMemo::VT_RECIPIENT, recipient);
        }
        #[inline]
        pub fn add_body(&mut self, body: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(UserMemo::VT_BODY, body);
        }
        #[inline]
        pub fn add_subject(&mut self, subject: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(UserMemo::VT_SUBJECT, subject);
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        ) -> UserMemoBuilder<'a, 'b, A> {
            let start = _fbb.start_table();
            UserMemoBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<UserMemo<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for UserMemo<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("UserMemo");
            ds.field("reply_to", &self.reply_to());
            ds.field("sender", &self.sender());
            ds.field("recipient", &self.recipient());
            ds.field("body", &self.body());
            ds.field("subject", &self.subject());
            ds.finish()
        }
    }
    #[non_exhaustive]
    #[derive(Serialize, Deserialize, Debug, Clone, PartialEq)]
    pub struct UserMemoT {
        pub reply_to: bool,
        pub sender: Option<String>,
        pub recipient: Option<String>,
        pub body: Option<String>,
        pub subject: Option<String>,
    }
    impl Default for UserMemoT {
        fn default() -> Self {
            Self {
                reply_to: false,
                sender: None,
                recipient: None,
                body: None,
                subject: None,
            }
        }
    }
    impl UserMemoT {
        pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
            &self,
            _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
        ) -> flatbuffers::WIPOffset<UserMemo<'b>> {
            let reply_to = self.reply_to;
            let sender = self.sender.as_ref().map(|x| _fbb.create_string(x));
            let recipient = self.recipient.as_ref().map(|x| _fbb.create_string(x));
            let body = self.body.as_ref().map(|x| _fbb.create_string(x));
            let subject = self.subject.as_ref().map(|x| _fbb.create_string(x));
            UserMemo::create(
                _fbb,
                &UserMemoArgs {
                    reply_to,
                    sender,
                    recipient,
                    body,
                    subject,
                },
            )
        }
    }
    pub enum ZIP32KeysOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct ZIP32Keys<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for ZIP32Keys<'a> {
        type Inner = ZIP32Keys<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> ZIP32Keys<'a> {
        pub const VT_TSK: flatbuffers::VOffsetT = 4;
        pub const VT_TADDRESS: flatbuffers::VOffsetT = 6;
        pub const VT_ZSK: flatbuffers::VOffsetT = 8;
        pub const VT_ZADDRESS: flatbuffers::VOffsetT = 10;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            ZIP32Keys { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<
            'bldr: 'args,
            'args: 'mut_bldr,
            'mut_bldr,
            A: flatbuffers::Allocator + 'bldr,
        >(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
            args: &'args ZIP32KeysArgs<'args>,
        ) -> flatbuffers::WIPOffset<ZIP32Keys<'bldr>> {
            let mut builder = ZIP32KeysBuilder::new(_fbb);
            if let Some(x) = args.zaddress {
                builder.add_zaddress(x);
            }
            if let Some(x) = args.zsk {
                builder.add_zsk(x);
            }
            if let Some(x) = args.taddress {
                builder.add_taddress(x);
            }
            if let Some(x) = args.tsk {
                builder.add_tsk(x);
            }
            builder.finish()
        }

        pub fn unpack(&self) -> ZIP32KeysT {
            let tsk = self.tsk().map(|x| x.to_string());
            let taddress = self.taddress().map(|x| x.to_string());
            let zsk = self.zsk().map(|x| x.to_string());
            let zaddress = self.zaddress().map(|x| x.to_string());
            ZIP32KeysT {
                tsk,
                taddress,
                zsk,
                zaddress,
            }
        }

        #[inline]
        pub fn tsk(&self) -> Option<&'a str> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<&str>>(ZIP32Keys::VT_TSK, None)
            }
        }
        #[inline]
        pub fn taddress(&self) -> Option<&'a str> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<&str>>(ZIP32Keys::VT_TADDRESS, None)
            }
        }
        #[inline]
        pub fn zsk(&self) -> Option<&'a str> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<&str>>(ZIP32Keys::VT_ZSK, None)
            }
        }
        #[inline]
        pub fn zaddress(&self) -> Option<&'a str> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<&str>>(ZIP32Keys::VT_ZADDRESS, None)
            }
        }
    }

    impl flatbuffers::Verifiable for ZIP32Keys<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<flatbuffers::ForwardsUOffset<&str>>("tsk", Self::VT_TSK, false)?
                .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                    "taddress",
                    Self::VT_TADDRESS,
                    false,
                )?
                .visit_field::<flatbuffers::ForwardsUOffset<&str>>("zsk", Self::VT_ZSK, false)?
                .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                    "zaddress",
                    Self::VT_ZADDRESS,
                    false,
                )?
                .finish();
            Ok(())
        }
    }
    pub struct ZIP32KeysArgs<'a> {
        pub tsk: Option<flatbuffers::WIPOffset<&'a str>>,
        pub taddress: Option<flatbuffers::WIPOffset<&'a str>>,
        pub zsk: Option<flatbuffers::WIPOffset<&'a str>>,
        pub zaddress: Option<flatbuffers::WIPOffset<&'a str>>,
    }
    impl<'a> Default for ZIP32KeysArgs<'a> {
        #[inline]
        fn default() -> Self {
            ZIP32KeysArgs {
                tsk: None,
                taddress: None,
                zsk: None,
                zaddress: None,
            }
        }
    }

    pub struct ZIP32KeysBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> ZIP32KeysBuilder<'a, 'b, A> {
        #[inline]
        pub fn add_tsk(&mut self, tsk: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(ZIP32Keys::VT_TSK, tsk);
        }
        #[inline]
        pub fn add_taddress(&mut self, taddress: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(ZIP32Keys::VT_TADDRESS, taddress);
        }
        #[inline]
        pub fn add_zsk(&mut self, zsk: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(ZIP32Keys::VT_ZSK, zsk);
        }
        #[inline]
        pub fn add_zaddress(&mut self, zaddress: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(ZIP32Keys::VT_ZADDRESS, zaddress);
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        ) -> ZIP32KeysBuilder<'a, 'b, A> {
            let start = _fbb.start_table();
            ZIP32KeysBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<ZIP32Keys<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for ZIP32Keys<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("ZIP32Keys");
            ds.field("tsk", &self.tsk());
            ds.field("taddress", &self.taddress());
            ds.field("zsk", &self.zsk());
            ds.field("zaddress", &self.zaddress());
            ds.finish()
        }
    }
    #[non_exhaustive]
    #[derive(Serialize, Deserialize, Debug, Clone, PartialEq)]
    pub struct ZIP32KeysT {
        pub tsk: Option<String>,
        pub taddress: Option<String>,
        pub zsk: Option<String>,
        pub zaddress: Option<String>,
    }
    impl Default for ZIP32KeysT {
        fn default() -> Self {
            Self {
                tsk: None,
                taddress: None,
                zsk: None,
                zaddress: None,
            }
        }
    }
    impl ZIP32KeysT {
        pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
            &self,
            _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
        ) -> flatbuffers::WIPOffset<ZIP32Keys<'b>> {
            let tsk = self.tsk.as_ref().map(|x| _fbb.create_string(x));
            let taddress = self.taddress.as_ref().map(|x| _fbb.create_string(x));
            let zsk = self.zsk.as_ref().map(|x| _fbb.create_string(x));
            let zaddress = self.zaddress.as_ref().map(|x| _fbb.create_string(x));
            ZIP32Keys::create(
                _fbb,
                &ZIP32KeysArgs {
                    tsk,
                    taddress,
                    zsk,
                    zaddress,
                },
            )
        }
    }
    pub enum ConfigOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct Config<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for Config<'a> {
        type Inner = Config<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> Config<'a> {
        pub const VT_DB_PATH: flatbuffers::VOffsetT = 4;
        pub const VT_LWD_URL: flatbuffers::VOffsetT = 6;
        pub const VT_WARP_URL: flatbuffers::VOffsetT = 8;
        pub const VT_WARP_END_HEIGHT: flatbuffers::VOffsetT = 10;
        pub const VT_CONFIRMATIONS: flatbuffers::VOffsetT = 12;
        pub const VT_REGTEST: flatbuffers::VOffsetT = 14;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            Config { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<
            'bldr: 'args,
            'args: 'mut_bldr,
            'mut_bldr,
            A: flatbuffers::Allocator + 'bldr,
        >(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
            args: &'args ConfigArgs<'args>,
        ) -> flatbuffers::WIPOffset<Config<'bldr>> {
            let mut builder = ConfigBuilder::new(_fbb);
            builder.add_confirmations(args.confirmations);
            builder.add_warp_end_height(args.warp_end_height);
            if let Some(x) = args.warp_url {
                builder.add_warp_url(x);
            }
            if let Some(x) = args.lwd_url {
                builder.add_lwd_url(x);
            }
            if let Some(x) = args.db_path {
                builder.add_db_path(x);
            }
            builder.add_regtest(args.regtest);
            builder.finish()
        }

        pub fn unpack(&self) -> ConfigT {
            let db_path = self.db_path().map(|x| x.to_string());
            let lwd_url = self.lwd_url().map(|x| x.to_string());
            let warp_url = self.warp_url().map(|x| x.to_string());
            let warp_end_height = self.warp_end_height();
            let confirmations = self.confirmations();
            let regtest = self.regtest();
            ConfigT {
                db_path,
                lwd_url,
                warp_url,
                warp_end_height,
                confirmations,
                regtest,
            }
        }

        #[inline]
        pub fn db_path(&self) -> Option<&'a str> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<&str>>(Config::VT_DB_PATH, None)
            }
        }
        #[inline]
        pub fn lwd_url(&self) -> Option<&'a str> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<&str>>(Config::VT_LWD_URL, None)
            }
        }
        #[inline]
        pub fn warp_url(&self) -> Option<&'a str> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<&str>>(Config::VT_WARP_URL, None)
            }
        }
        #[inline]
        pub fn warp_end_height(&self) -> u32 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<u32>(Config::VT_WARP_END_HEIGHT, Some(0))
                    .unwrap()
            }
        }
        #[inline]
        pub fn confirmations(&self) -> u32 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<u32>(Config::VT_CONFIRMATIONS, Some(0))
                    .unwrap()
            }
        }
        #[inline]
        pub fn regtest(&self) -> bool {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<bool>(Config::VT_REGTEST, Some(false))
                    .unwrap()
            }
        }
    }

    impl flatbuffers::Verifiable for Config<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                    "db_path",
                    Self::VT_DB_PATH,
                    false,
                )?
                .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                    "lwd_url",
                    Self::VT_LWD_URL,
                    false,
                )?
                .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                    "warp_url",
                    Self::VT_WARP_URL,
                    false,
                )?
                .visit_field::<u32>("warp_end_height", Self::VT_WARP_END_HEIGHT, false)?
                .visit_field::<u32>("confirmations", Self::VT_CONFIRMATIONS, false)?
                .visit_field::<bool>("regtest", Self::VT_REGTEST, false)?
                .finish();
            Ok(())
        }
    }
    pub struct ConfigArgs<'a> {
        pub db_path: Option<flatbuffers::WIPOffset<&'a str>>,
        pub lwd_url: Option<flatbuffers::WIPOffset<&'a str>>,
        pub warp_url: Option<flatbuffers::WIPOffset<&'a str>>,
        pub warp_end_height: u32,
        pub confirmations: u32,
        pub regtest: bool,
    }
    impl<'a> Default for ConfigArgs<'a> {
        #[inline]
        fn default() -> Self {
            ConfigArgs {
                db_path: None,
                lwd_url: None,
                warp_url: None,
                warp_end_height: 0,
                confirmations: 0,
                regtest: false,
            }
        }
    }

    pub struct ConfigBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> ConfigBuilder<'a, 'b, A> {
        #[inline]
        pub fn add_db_path(&mut self, db_path: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(Config::VT_DB_PATH, db_path);
        }
        #[inline]
        pub fn add_lwd_url(&mut self, lwd_url: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(Config::VT_LWD_URL, lwd_url);
        }
        #[inline]
        pub fn add_warp_url(&mut self, warp_url: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(Config::VT_WARP_URL, warp_url);
        }
        #[inline]
        pub fn add_warp_end_height(&mut self, warp_end_height: u32) {
            self.fbb_
                .push_slot::<u32>(Config::VT_WARP_END_HEIGHT, warp_end_height, 0);
        }
        #[inline]
        pub fn add_confirmations(&mut self, confirmations: u32) {
            self.fbb_
                .push_slot::<u32>(Config::VT_CONFIRMATIONS, confirmations, 0);
        }
        #[inline]
        pub fn add_regtest(&mut self, regtest: bool) {
            self.fbb_
                .push_slot::<bool>(Config::VT_REGTEST, regtest, false);
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        ) -> ConfigBuilder<'a, 'b, A> {
            let start = _fbb.start_table();
            ConfigBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<Config<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for Config<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("Config");
            ds.field("db_path", &self.db_path());
            ds.field("lwd_url", &self.lwd_url());
            ds.field("warp_url", &self.warp_url());
            ds.field("warp_end_height", &self.warp_end_height());
            ds.field("confirmations", &self.confirmations());
            ds.field("regtest", &self.regtest());
            ds.finish()
        }
    }
    #[non_exhaustive]
    #[derive(Serialize, Deserialize, Debug, Clone, PartialEq)]
    pub struct ConfigT {
        pub db_path: Option<String>,
        pub lwd_url: Option<String>,
        pub warp_url: Option<String>,
        pub warp_end_height: u32,
        pub confirmations: u32,
        pub regtest: bool,
    }
    impl Default for ConfigT {
        fn default() -> Self {
            Self {
                db_path: None,
                lwd_url: None,
                warp_url: None,
                warp_end_height: 0,
                confirmations: 0,
                regtest: false,
            }
        }
    }
    impl ConfigT {
        pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
            &self,
            _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
        ) -> flatbuffers::WIPOffset<Config<'b>> {
            let db_path = self.db_path.as_ref().map(|x| _fbb.create_string(x));
            let lwd_url = self.lwd_url.as_ref().map(|x| _fbb.create_string(x));
            let warp_url = self.warp_url.as_ref().map(|x| _fbb.create_string(x));
            let warp_end_height = self.warp_end_height;
            let confirmations = self.confirmations;
            let regtest = self.regtest;
            Config::create(
                _fbb,
                &ConfigArgs {
                    db_path,
                    lwd_url,
                    warp_url,
                    warp_end_height,
                    confirmations,
                    regtest,
                },
            )
        }
    }
    pub enum AccountSigningCapabilitiesOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct AccountSigningCapabilities<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for AccountSigningCapabilities<'a> {
        type Inner = AccountSigningCapabilities<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> AccountSigningCapabilities<'a> {
        pub const VT_SEED: flatbuffers::VOffsetT = 4;
        pub const VT_TRANSPARENT: flatbuffers::VOffsetT = 6;
        pub const VT_SAPLING: flatbuffers::VOffsetT = 8;
        pub const VT_ORCHARD: flatbuffers::VOffsetT = 10;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            AccountSigningCapabilities { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<
            'bldr: 'args,
            'args: 'mut_bldr,
            'mut_bldr,
            A: flatbuffers::Allocator + 'bldr,
        >(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
            args: &'args AccountSigningCapabilitiesArgs,
        ) -> flatbuffers::WIPOffset<AccountSigningCapabilities<'bldr>> {
            let mut builder = AccountSigningCapabilitiesBuilder::new(_fbb);
            builder.add_orchard(args.orchard);
            builder.add_sapling(args.sapling);
            builder.add_transparent(args.transparent);
            builder.add_seed(args.seed);
            builder.finish()
        }

        pub fn unpack(&self) -> AccountSigningCapabilitiesT {
            let seed = self.seed();
            let transparent = self.transparent();
            let sapling = self.sapling();
            let orchard = self.orchard();
            AccountSigningCapabilitiesT {
                seed,
                transparent,
                sapling,
                orchard,
            }
        }

        #[inline]
        pub fn seed(&self) -> bool {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<bool>(AccountSigningCapabilities::VT_SEED, Some(false))
                    .unwrap()
            }
        }
        #[inline]
        pub fn transparent(&self) -> u8 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<u8>(AccountSigningCapabilities::VT_TRANSPARENT, Some(0))
                    .unwrap()
            }
        }
        #[inline]
        pub fn sapling(&self) -> u8 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<u8>(AccountSigningCapabilities::VT_SAPLING, Some(0))
                    .unwrap()
            }
        }
        #[inline]
        pub fn orchard(&self) -> u8 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<u8>(AccountSigningCapabilities::VT_ORCHARD, Some(0))
                    .unwrap()
            }
        }
    }

    impl flatbuffers::Verifiable for AccountSigningCapabilities<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<bool>("seed", Self::VT_SEED, false)?
                .visit_field::<u8>("transparent", Self::VT_TRANSPARENT, false)?
                .visit_field::<u8>("sapling", Self::VT_SAPLING, false)?
                .visit_field::<u8>("orchard", Self::VT_ORCHARD, false)?
                .finish();
            Ok(())
        }
    }
    pub struct AccountSigningCapabilitiesArgs {
        pub seed: bool,
        pub transparent: u8,
        pub sapling: u8,
        pub orchard: u8,
    }
    impl<'a> Default for AccountSigningCapabilitiesArgs {
        #[inline]
        fn default() -> Self {
            AccountSigningCapabilitiesArgs {
                seed: false,
                transparent: 0,
                sapling: 0,
                orchard: 0,
            }
        }
    }

    pub struct AccountSigningCapabilitiesBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> AccountSigningCapabilitiesBuilder<'a, 'b, A> {
        #[inline]
        pub fn add_seed(&mut self, seed: bool) {
            self.fbb_
                .push_slot::<bool>(AccountSigningCapabilities::VT_SEED, seed, false);
        }
        #[inline]
        pub fn add_transparent(&mut self, transparent: u8) {
            self.fbb_
                .push_slot::<u8>(AccountSigningCapabilities::VT_TRANSPARENT, transparent, 0);
        }
        #[inline]
        pub fn add_sapling(&mut self, sapling: u8) {
            self.fbb_
                .push_slot::<u8>(AccountSigningCapabilities::VT_SAPLING, sapling, 0);
        }
        #[inline]
        pub fn add_orchard(&mut self, orchard: u8) {
            self.fbb_
                .push_slot::<u8>(AccountSigningCapabilities::VT_ORCHARD, orchard, 0);
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        ) -> AccountSigningCapabilitiesBuilder<'a, 'b, A> {
            let start = _fbb.start_table();
            AccountSigningCapabilitiesBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<AccountSigningCapabilities<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for AccountSigningCapabilities<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("AccountSigningCapabilities");
            ds.field("seed", &self.seed());
            ds.field("transparent", &self.transparent());
            ds.field("sapling", &self.sapling());
            ds.field("orchard", &self.orchard());
            ds.finish()
        }
    }
    #[non_exhaustive]
    #[derive(Serialize, Deserialize, Debug, Clone, PartialEq)]
    pub struct AccountSigningCapabilitiesT {
        pub seed: bool,
        pub transparent: u8,
        pub sapling: u8,
        pub orchard: u8,
    }
    impl Default for AccountSigningCapabilitiesT {
        fn default() -> Self {
            Self {
                seed: false,
                transparent: 0,
                sapling: 0,
                orchard: 0,
            }
        }
    }
    impl AccountSigningCapabilitiesT {
        pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
            &self,
            _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
        ) -> flatbuffers::WIPOffset<AccountSigningCapabilities<'b>> {
            let seed = self.seed;
            let transparent = self.transparent;
            let sapling = self.sapling;
            let orchard = self.orchard;
            AccountSigningCapabilities::create(
                _fbb,
                &AccountSigningCapabilitiesArgs {
                    seed,
                    transparent,
                    sapling,
                    orchard,
                },
            )
        }
    }
    pub enum SchemaVersionOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct SchemaVersion<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for SchemaVersion<'a> {
        type Inner = SchemaVersion<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> SchemaVersion<'a> {
        pub const VT_MAJOR: flatbuffers::VOffsetT = 4;
        pub const VT_MINOR: flatbuffers::VOffsetT = 6;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            SchemaVersion { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<
            'bldr: 'args,
            'args: 'mut_bldr,
            'mut_bldr,
            A: flatbuffers::Allocator + 'bldr,
        >(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
            args: &'args SchemaVersionArgs,
        ) -> flatbuffers::WIPOffset<SchemaVersion<'bldr>> {
            let mut builder = SchemaVersionBuilder::new(_fbb);
            builder.add_minor(args.minor);
            builder.add_major(args.major);
            builder.finish()
        }

        pub fn unpack(&self) -> SchemaVersionT {
            let major = self.major();
            let minor = self.minor();
            SchemaVersionT { major, minor }
        }

        #[inline]
        pub fn major(&self) -> u8 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<u8>(SchemaVersion::VT_MAJOR, Some(0))
                    .unwrap()
            }
        }
        #[inline]
        pub fn minor(&self) -> u8 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<u8>(SchemaVersion::VT_MINOR, Some(0))
                    .unwrap()
            }
        }
    }

    impl flatbuffers::Verifiable for SchemaVersion<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<u8>("major", Self::VT_MAJOR, false)?
                .visit_field::<u8>("minor", Self::VT_MINOR, false)?
                .finish();
            Ok(())
        }
    }
    pub struct SchemaVersionArgs {
        pub major: u8,
        pub minor: u8,
    }
    impl<'a> Default for SchemaVersionArgs {
        #[inline]
        fn default() -> Self {
            SchemaVersionArgs { major: 0, minor: 0 }
        }
    }

    pub struct SchemaVersionBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> SchemaVersionBuilder<'a, 'b, A> {
        #[inline]
        pub fn add_major(&mut self, major: u8) {
            self.fbb_.push_slot::<u8>(SchemaVersion::VT_MAJOR, major, 0);
        }
        #[inline]
        pub fn add_minor(&mut self, minor: u8) {
            self.fbb_.push_slot::<u8>(SchemaVersion::VT_MINOR, minor, 0);
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        ) -> SchemaVersionBuilder<'a, 'b, A> {
            let start = _fbb.start_table();
            SchemaVersionBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<SchemaVersion<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for SchemaVersion<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("SchemaVersion");
            ds.field("major", &self.major());
            ds.field("minor", &self.minor());
            ds.finish()
        }
    }
    #[non_exhaustive]
    #[derive(Serialize, Deserialize, Debug, Clone, PartialEq)]
    pub struct SchemaVersionT {
        pub major: u8,
        pub minor: u8,
    }
    impl Default for SchemaVersionT {
        fn default() -> Self {
            Self { major: 0, minor: 0 }
        }
    }
    impl SchemaVersionT {
        pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
            &self,
            _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
        ) -> flatbuffers::WIPOffset<SchemaVersion<'b>> {
            let major = self.major;
            let minor = self.minor;
            SchemaVersion::create(_fbb, &SchemaVersionArgs { major, minor })
        }
    }
    pub enum ZipDbConfigOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct ZipDbConfig<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for ZipDbConfig<'a> {
        type Inner = ZipDbConfig<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> ZipDbConfig<'a> {
        pub const VT_DIRECTORY: flatbuffers::VOffsetT = 4;
        pub const VT_FILE_LIST: flatbuffers::VOffsetT = 6;
        pub const VT_TARGET_PATH: flatbuffers::VOffsetT = 8;
        pub const VT_PUBLIC_KEY: flatbuffers::VOffsetT = 10;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            ZipDbConfig { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<
            'bldr: 'args,
            'args: 'mut_bldr,
            'mut_bldr,
            A: flatbuffers::Allocator + 'bldr,
        >(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
            args: &'args ZipDbConfigArgs<'args>,
        ) -> flatbuffers::WIPOffset<ZipDbConfig<'bldr>> {
            let mut builder = ZipDbConfigBuilder::new(_fbb);
            if let Some(x) = args.public_key {
                builder.add_public_key(x);
            }
            if let Some(x) = args.target_path {
                builder.add_target_path(x);
            }
            if let Some(x) = args.file_list {
                builder.add_file_list(x);
            }
            if let Some(x) = args.directory {
                builder.add_directory(x);
            }
            builder.finish()
        }

        pub fn unpack(&self) -> ZipDbConfigT {
            let directory = self.directory().map(|x| x.to_string());
            let file_list = self
                .file_list()
                .map(|x| x.iter().map(|s| s.to_string()).collect());
            let target_path = self.target_path().map(|x| x.to_string());
            let public_key = self.public_key().map(|x| x.to_string());
            ZipDbConfigT {
                directory,
                file_list,
                target_path,
                public_key,
            }
        }

        #[inline]
        pub fn directory(&self) -> Option<&'a str> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<&str>>(ZipDbConfig::VT_DIRECTORY, None)
            }
        }
        #[inline]
        pub fn file_list(
            &self,
        ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab.get::<flatbuffers::ForwardsUOffset<
                    flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>,
                >>(ZipDbConfig::VT_FILE_LIST, None)
            }
        }
        #[inline]
        pub fn target_path(&self) -> Option<&'a str> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<&str>>(ZipDbConfig::VT_TARGET_PATH, None)
            }
        }
        #[inline]
        pub fn public_key(&self) -> Option<&'a str> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<&str>>(ZipDbConfig::VT_PUBLIC_KEY, None)
            }
        }
    }

    impl flatbuffers::Verifiable for ZipDbConfig<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                    "directory",
                    Self::VT_DIRECTORY,
                    false,
                )?
                .visit_field::<flatbuffers::ForwardsUOffset<
                    flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>,
                >>("file_list", Self::VT_FILE_LIST, false)?
                .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                    "target_path",
                    Self::VT_TARGET_PATH,
                    false,
                )?
                .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                    "public_key",
                    Self::VT_PUBLIC_KEY,
                    false,
                )?
                .finish();
            Ok(())
        }
    }
    pub struct ZipDbConfigArgs<'a> {
        pub directory: Option<flatbuffers::WIPOffset<&'a str>>,
        pub file_list: Option<
            flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>,
        >,
        pub target_path: Option<flatbuffers::WIPOffset<&'a str>>,
        pub public_key: Option<flatbuffers::WIPOffset<&'a str>>,
    }
    impl<'a> Default for ZipDbConfigArgs<'a> {
        #[inline]
        fn default() -> Self {
            ZipDbConfigArgs {
                directory: None,
                file_list: None,
                target_path: None,
                public_key: None,
            }
        }
    }

    pub struct ZipDbConfigBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> ZipDbConfigBuilder<'a, 'b, A> {
        #[inline]
        pub fn add_directory(&mut self, directory: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                ZipDbConfig::VT_DIRECTORY,
                directory,
            );
        }
        #[inline]
        pub fn add_file_list(
            &mut self,
            file_list: flatbuffers::WIPOffset<
                flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<&'b str>>,
            >,
        ) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                ZipDbConfig::VT_FILE_LIST,
                file_list,
            );
        }
        #[inline]
        pub fn add_target_path(&mut self, target_path: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                ZipDbConfig::VT_TARGET_PATH,
                target_path,
            );
        }
        #[inline]
        pub fn add_public_key(&mut self, public_key: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                ZipDbConfig::VT_PUBLIC_KEY,
                public_key,
            );
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        ) -> ZipDbConfigBuilder<'a, 'b, A> {
            let start = _fbb.start_table();
            ZipDbConfigBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<ZipDbConfig<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for ZipDbConfig<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("ZipDbConfig");
            ds.field("directory", &self.directory());
            ds.field("file_list", &self.file_list());
            ds.field("target_path", &self.target_path());
            ds.field("public_key", &self.public_key());
            ds.finish()
        }
    }
    #[non_exhaustive]
    #[derive(Serialize, Deserialize, Debug, Clone, PartialEq)]
    pub struct ZipDbConfigT {
        pub directory: Option<String>,
        pub file_list: Option<Vec<String>>,
        pub target_path: Option<String>,
        pub public_key: Option<String>,
    }
    impl Default for ZipDbConfigT {
        fn default() -> Self {
            Self {
                directory: None,
                file_list: None,
                target_path: None,
                public_key: None,
            }
        }
    }
    impl ZipDbConfigT {
        pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
            &self,
            _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
        ) -> flatbuffers::WIPOffset<ZipDbConfig<'b>> {
            let directory = self.directory.as_ref().map(|x| _fbb.create_string(x));
            let file_list = self.file_list.as_ref().map(|x| {
                let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();
                _fbb.create_vector(&w)
            });
            let target_path = self.target_path.as_ref().map(|x| _fbb.create_string(x));
            let public_key = self.public_key.as_ref().map(|x| _fbb.create_string(x));
            ZipDbConfig::create(
                _fbb,
                &ZipDbConfigArgs {
                    directory,
                    file_list,
                    target_path,
                    public_key,
                },
            )
        }
    }
    pub enum TransparentAddressOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct TransparentAddress<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for TransparentAddress<'a> {
        type Inner = TransparentAddress<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> TransparentAddress<'a> {
        pub const VT_ADDR_INDEX: flatbuffers::VOffsetT = 4;
        pub const VT_ADDRESS: flatbuffers::VOffsetT = 6;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            TransparentAddress { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<
            'bldr: 'args,
            'args: 'mut_bldr,
            'mut_bldr,
            A: flatbuffers::Allocator + 'bldr,
        >(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
            args: &'args TransparentAddressArgs<'args>,
        ) -> flatbuffers::WIPOffset<TransparentAddress<'bldr>> {
            let mut builder = TransparentAddressBuilder::new(_fbb);
            if let Some(x) = args.address {
                builder.add_address(x);
            }
            builder.add_addr_index(args.addr_index);
            builder.finish()
        }

        pub fn unpack(&self) -> TransparentAddressT {
            let addr_index = self.addr_index();
            let address = self.address().map(|x| x.to_string());
            TransparentAddressT {
                addr_index,
                address,
            }
        }

        #[inline]
        pub fn addr_index(&self) -> u32 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<u32>(TransparentAddress::VT_ADDR_INDEX, Some(0))
                    .unwrap()
            }
        }
        #[inline]
        pub fn address(&self) -> Option<&'a str> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<&str>>(TransparentAddress::VT_ADDRESS, None)
            }
        }
    }

    impl flatbuffers::Verifiable for TransparentAddress<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<u32>("addr_index", Self::VT_ADDR_INDEX, false)?
                .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                    "address",
                    Self::VT_ADDRESS,
                    false,
                )?
                .finish();
            Ok(())
        }
    }
    pub struct TransparentAddressArgs<'a> {
        pub addr_index: u32,
        pub address: Option<flatbuffers::WIPOffset<&'a str>>,
    }
    impl<'a> Default for TransparentAddressArgs<'a> {
        #[inline]
        fn default() -> Self {
            TransparentAddressArgs {
                addr_index: 0,
                address: None,
            }
        }
    }

    pub struct TransparentAddressBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> TransparentAddressBuilder<'a, 'b, A> {
        #[inline]
        pub fn add_addr_index(&mut self, addr_index: u32) {
            self.fbb_
                .push_slot::<u32>(TransparentAddress::VT_ADDR_INDEX, addr_index, 0);
        }
        #[inline]
        pub fn add_address(&mut self, address: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                TransparentAddress::VT_ADDRESS,
                address,
            );
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        ) -> TransparentAddressBuilder<'a, 'b, A> {
            let start = _fbb.start_table();
            TransparentAddressBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<TransparentAddress<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for TransparentAddress<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("TransparentAddress");
            ds.field("addr_index", &self.addr_index());
            ds.field("address", &self.address());
            ds.finish()
        }
    }
    #[non_exhaustive]
    #[derive(Serialize, Deserialize, Debug, Clone, PartialEq)]
    pub struct TransparentAddressT {
        pub addr_index: u32,
        pub address: Option<String>,
    }
    impl Default for TransparentAddressT {
        fn default() -> Self {
            Self {
                addr_index: 0,
                address: None,
            }
        }
    }
    impl TransparentAddressT {
        pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
            &self,
            _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
        ) -> flatbuffers::WIPOffset<TransparentAddress<'b>> {
            let addr_index = self.addr_index;
            let address = self.address.as_ref().map(|x| _fbb.create_string(x));
            TransparentAddress::create(
                _fbb,
                &TransparentAddressArgs {
                    addr_index,
                    address,
                },
            )
        }
    }
    pub enum TransactionBytesOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct TransactionBytes<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for TransactionBytes<'a> {
        type Inner = TransactionBytes<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> TransactionBytes<'a> {
        pub const VT_NOTES: flatbuffers::VOffsetT = 4;
        pub const VT_DATA: flatbuffers::VOffsetT = 6;
        pub const VT_REDIRECT: flatbuffers::VOffsetT = 8;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            TransactionBytes { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<
            'bldr: 'args,
            'args: 'mut_bldr,
            'mut_bldr,
            A: flatbuffers::Allocator + 'bldr,
        >(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
            args: &'args TransactionBytesArgs<'args>,
        ) -> flatbuffers::WIPOffset<TransactionBytes<'bldr>> {
            let mut builder = TransactionBytesBuilder::new(_fbb);
            if let Some(x) = args.redirect {
                builder.add_redirect(x);
            }
            if let Some(x) = args.data {
                builder.add_data(x);
            }
            if let Some(x) = args.notes {
                builder.add_notes(x);
            }
            builder.finish()
        }

        pub fn unpack(&self) -> TransactionBytesT {
            let notes = self.notes().map(|x| x.iter().map(|t| t.unpack()).collect());
            let data = self.data().map(|x| x.into_iter().collect());
            let redirect = self.redirect().map(|x| x.to_string());
            TransactionBytesT {
                notes,
                data,
                redirect,
            }
        }

        #[inline]
        pub fn notes(&self) -> Option<flatbuffers::Vector<'a, IdNote>> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, IdNote>>>(
                        TransactionBytes::VT_NOTES,
                        None,
                    )
            }
        }
        #[inline]
        pub fn data(&self) -> Option<flatbuffers::Vector<'a, u8>> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(
                        TransactionBytes::VT_DATA,
                        None,
                    )
            }
        }
        #[inline]
        pub fn redirect(&self) -> Option<&'a str> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<&str>>(TransactionBytes::VT_REDIRECT, None)
            }
        }
    }

    impl flatbuffers::Verifiable for TransactionBytes<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, IdNote>>>(
                    "notes",
                    Self::VT_NOTES,
                    false,
                )?
                .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>(
                    "data",
                    Self::VT_DATA,
                    false,
                )?
                .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                    "redirect",
                    Self::VT_REDIRECT,
                    false,
                )?
                .finish();
            Ok(())
        }
    }
    pub struct TransactionBytesArgs<'a> {
        pub notes: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, IdNote>>>,
        pub data: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
        pub redirect: Option<flatbuffers::WIPOffset<&'a str>>,
    }
    impl<'a> Default for TransactionBytesArgs<'a> {
        #[inline]
        fn default() -> Self {
            TransactionBytesArgs {
                notes: None,
                data: None,
                redirect: None,
            }
        }
    }

    pub struct TransactionBytesBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> TransactionBytesBuilder<'a, 'b, A> {
        #[inline]
        pub fn add_notes(
            &mut self,
            notes: flatbuffers::WIPOffset<flatbuffers::Vector<'b, IdNote>>,
        ) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(TransactionBytes::VT_NOTES, notes);
        }
        #[inline]
        pub fn add_data(&mut self, data: flatbuffers::WIPOffset<flatbuffers::Vector<'b, u8>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(TransactionBytes::VT_DATA, data);
        }
        #[inline]
        pub fn add_redirect(&mut self, redirect: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                TransactionBytes::VT_REDIRECT,
                redirect,
            );
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        ) -> TransactionBytesBuilder<'a, 'b, A> {
            let start = _fbb.start_table();
            TransactionBytesBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<TransactionBytes<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for TransactionBytes<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("TransactionBytes");
            ds.field("notes", &self.notes());
            ds.field("data", &self.data());
            ds.field("redirect", &self.redirect());
            ds.finish()
        }
    }
    #[non_exhaustive]
    #[derive(Serialize, Deserialize, Debug, Clone, PartialEq)]
    pub struct TransactionBytesT {
        pub notes: Option<Vec<IdNoteT>>,
        pub data: Option<Vec<u8>>,
        pub redirect: Option<String>,
    }
    impl Default for TransactionBytesT {
        fn default() -> Self {
            Self {
                notes: None,
                data: None,
                redirect: None,
            }
        }
    }
    impl TransactionBytesT {
        pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
            &self,
            _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
        ) -> flatbuffers::WIPOffset<TransactionBytes<'b>> {
            let notes = self.notes.as_ref().map(|x| {
                let w: Vec<_> = x.iter().map(|t| t.pack()).collect();
                _fbb.create_vector(&w)
            });
            let data = self.data.as_ref().map(|x| _fbb.create_vector(x));
            let redirect = self.redirect.as_ref().map(|x| _fbb.create_string(x));
            TransactionBytes::create(
                _fbb,
                &TransactionBytesArgs {
                    notes,
                    data,
                    redirect,
                },
            )
        }
    }
} // pub mod fb
