// automatically generated by the FlatBuffers compiler, do not modify


// @generated

use core::mem;
use core::cmp::Ordering;

extern crate flatbuffers;
use serde::{Serialize, Deserialize};
use self::flatbuffers::{EndianScalar, Follow};

#[allow(unused_imports, dead_code)]
pub mod fb {

  use core::mem;
  use core::cmp::Ordering;

  extern crate flatbuffers;
use serde::{Serialize, Deserialize};
  use self::flatbuffers::{EndianScalar, Follow};

pub enum BackupOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Backup<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Backup<'a> {
  type Inner = Backup<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> Backup<'a> {
  pub const VT_NAME: flatbuffers::VOffsetT = 4;
  pub const VT_SEED: flatbuffers::VOffsetT = 6;
  pub const VT_INDEX: flatbuffers::VOffsetT = 8;
  pub const VT_SK: flatbuffers::VOffsetT = 10;
  pub const VT_FVK: flatbuffers::VOffsetT = 12;
  pub const VT_UVK: flatbuffers::VOffsetT = 14;
  pub const VT_TSK: flatbuffers::VOffsetT = 16;
  pub const VT_SAVED: flatbuffers::VOffsetT = 18;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Backup { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args BackupArgs<'args>
  ) -> flatbuffers::WIPOffset<Backup<'bldr>> {
    let mut builder = BackupBuilder::new(_fbb);
    if let Some(x) = args.tsk { builder.add_tsk(x); }
    if let Some(x) = args.uvk { builder.add_uvk(x); }
    if let Some(x) = args.fvk { builder.add_fvk(x); }
    if let Some(x) = args.sk { builder.add_sk(x); }
    builder.add_index(args.index);
    if let Some(x) = args.seed { builder.add_seed(x); }
    if let Some(x) = args.name { builder.add_name(x); }
    builder.add_saved(args.saved);
    builder.finish()
  }

  pub fn unpack(&self) -> BackupT {
    let name = self.name().map(|x| {
      x.to_string()
    });
    let seed = self.seed().map(|x| {
      x.to_string()
    });
    let index = self.index();
    let sk = self.sk().map(|x| {
      x.to_string()
    });
    let fvk = self.fvk().map(|x| {
      x.to_string()
    });
    let uvk = self.uvk().map(|x| {
      x.to_string()
    });
    let tsk = self.tsk().map(|x| {
      x.to_string()
    });
    let saved = self.saved();
    BackupT {
      name,
      seed,
      index,
      sk,
      fvk,
      uvk,
      tsk,
      saved,
    }
  }

  #[inline]
  pub fn name(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Backup::VT_NAME, None)}
  }
  #[inline]
  pub fn seed(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Backup::VT_SEED, None)}
  }
  #[inline]
  pub fn index(&self) -> u32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u32>(Backup::VT_INDEX, Some(0)).unwrap()}
  }
  #[inline]
  pub fn sk(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Backup::VT_SK, None)}
  }
  #[inline]
  pub fn fvk(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Backup::VT_FVK, None)}
  }
  #[inline]
  pub fn uvk(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Backup::VT_UVK, None)}
  }
  #[inline]
  pub fn tsk(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Backup::VT_TSK, None)}
  }
  #[inline]
  pub fn saved(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(Backup::VT_SAVED, Some(false)).unwrap()}
  }
}

impl flatbuffers::Verifiable for Backup<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("name", Self::VT_NAME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("seed", Self::VT_SEED, false)?
     .visit_field::<u32>("index", Self::VT_INDEX, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("sk", Self::VT_SK, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("fvk", Self::VT_FVK, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("uvk", Self::VT_UVK, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("tsk", Self::VT_TSK, false)?
     .visit_field::<bool>("saved", Self::VT_SAVED, false)?
     .finish();
    Ok(())
  }
}
pub struct BackupArgs<'a> {
    pub name: Option<flatbuffers::WIPOffset<&'a str>>,
    pub seed: Option<flatbuffers::WIPOffset<&'a str>>,
    pub index: u32,
    pub sk: Option<flatbuffers::WIPOffset<&'a str>>,
    pub fvk: Option<flatbuffers::WIPOffset<&'a str>>,
    pub uvk: Option<flatbuffers::WIPOffset<&'a str>>,
    pub tsk: Option<flatbuffers::WIPOffset<&'a str>>,
    pub saved: bool,
}
impl<'a> Default for BackupArgs<'a> {
  #[inline]
  fn default() -> Self {
    BackupArgs {
      name: None,
      seed: None,
      index: 0,
      sk: None,
      fvk: None,
      uvk: None,
      tsk: None,
      saved: false,
    }
  }
}

pub struct BackupBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> BackupBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Backup::VT_NAME, name);
  }
  #[inline]
  pub fn add_seed(&mut self, seed: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Backup::VT_SEED, seed);
  }
  #[inline]
  pub fn add_index(&mut self, index: u32) {
    self.fbb_.push_slot::<u32>(Backup::VT_INDEX, index, 0);
  }
  #[inline]
  pub fn add_sk(&mut self, sk: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Backup::VT_SK, sk);
  }
  #[inline]
  pub fn add_fvk(&mut self, fvk: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Backup::VT_FVK, fvk);
  }
  #[inline]
  pub fn add_uvk(&mut self, uvk: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Backup::VT_UVK, uvk);
  }
  #[inline]
  pub fn add_tsk(&mut self, tsk: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Backup::VT_TSK, tsk);
  }
  #[inline]
  pub fn add_saved(&mut self, saved: bool) {
    self.fbb_.push_slot::<bool>(Backup::VT_SAVED, saved, false);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> BackupBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    BackupBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Backup<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Backup<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Backup");
      ds.field("name", &self.name());
      ds.field("seed", &self.seed());
      ds.field("index", &self.index());
      ds.field("sk", &self.sk());
      ds.field("fvk", &self.fvk());
      ds.field("uvk", &self.uvk());
      ds.field("tsk", &self.tsk());
      ds.field("saved", &self.saved());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Serialize, Deserialize, Debug, Clone, PartialEq)]
pub struct BackupT {
  pub name: Option<String>,
  pub seed: Option<String>,
  pub index: u32,
  pub sk: Option<String>,
  pub fvk: Option<String>,
  pub uvk: Option<String>,
  pub tsk: Option<String>,
  pub saved: bool,
}
impl Default for BackupT {
  fn default() -> Self {
    Self {
      name: None,
      seed: None,
      index: 0,
      sk: None,
      fvk: None,
      uvk: None,
      tsk: None,
      saved: false,
    }
  }
}
impl BackupT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<Backup<'b>> {
    let name = self.name.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let seed = self.seed.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let index = self.index;
    let sk = self.sk.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let fvk = self.fvk.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let uvk = self.uvk.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let tsk = self.tsk.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let saved = self.saved;
    Backup::create(_fbb, &BackupArgs{
      name,
      seed,
      index,
      sk,
      fvk,
      uvk,
      tsk,
      saved,
    })
  }
}
pub enum TransactionInfoOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct TransactionInfo<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for TransactionInfo<'a> {
  type Inner = TransactionInfo<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> TransactionInfo<'a> {
  pub const VT_ID: flatbuffers::VOffsetT = 4;
  pub const VT_TXID: flatbuffers::VOffsetT = 6;
  pub const VT_HEIGHT: flatbuffers::VOffsetT = 8;
  pub const VT_CONFIRMATIONS: flatbuffers::VOffsetT = 10;
  pub const VT_TIMESTAMP: flatbuffers::VOffsetT = 12;
  pub const VT_AMOUNT: flatbuffers::VOffsetT = 14;
  pub const VT_ADDRESS: flatbuffers::VOffsetT = 16;
  pub const VT_CONTACT: flatbuffers::VOffsetT = 18;
  pub const VT_MEMO: flatbuffers::VOffsetT = 20;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    TransactionInfo { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args TransactionInfoArgs<'args>
  ) -> flatbuffers::WIPOffset<TransactionInfo<'bldr>> {
    let mut builder = TransactionInfoBuilder::new(_fbb);
    builder.add_amount(args.amount);
    if let Some(x) = args.memo { builder.add_memo(x); }
    if let Some(x) = args.contact { builder.add_contact(x); }
    if let Some(x) = args.address { builder.add_address(x); }
    builder.add_timestamp(args.timestamp);
    builder.add_confirmations(args.confirmations);
    builder.add_height(args.height);
    if let Some(x) = args.txid { builder.add_txid(x); }
    builder.add_id(args.id);
    builder.finish()
  }

  pub fn unpack(&self) -> TransactionInfoT {
    let id = self.id();
    let txid = self.txid().map(|x| {
      x.to_string()
    });
    let height = self.height();
    let confirmations = self.confirmations();
    let timestamp = self.timestamp();
    let amount = self.amount();
    let address = self.address().map(|x| {
      x.to_string()
    });
    let contact = self.contact().map(|x| {
      x.to_string()
    });
    let memo = self.memo().map(|x| {
      x.to_string()
    });
    TransactionInfoT {
      id,
      txid,
      height,
      confirmations,
      timestamp,
      amount,
      address,
      contact,
      memo,
    }
  }

  #[inline]
  pub fn id(&self) -> u32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u32>(TransactionInfo::VT_ID, Some(0)).unwrap()}
  }
  #[inline]
  pub fn txid(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(TransactionInfo::VT_TXID, None)}
  }
  #[inline]
  pub fn height(&self) -> u32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u32>(TransactionInfo::VT_HEIGHT, Some(0)).unwrap()}
  }
  #[inline]
  pub fn confirmations(&self) -> u32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u32>(TransactionInfo::VT_CONFIRMATIONS, Some(0)).unwrap()}
  }
  #[inline]
  pub fn timestamp(&self) -> u32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u32>(TransactionInfo::VT_TIMESTAMP, Some(0)).unwrap()}
  }
  #[inline]
  pub fn amount(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(TransactionInfo::VT_AMOUNT, Some(0)).unwrap()}
  }
  #[inline]
  pub fn address(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(TransactionInfo::VT_ADDRESS, None)}
  }
  #[inline]
  pub fn contact(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(TransactionInfo::VT_CONTACT, None)}
  }
  #[inline]
  pub fn memo(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(TransactionInfo::VT_MEMO, None)}
  }
}

impl flatbuffers::Verifiable for TransactionInfo<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<u32>("id", Self::VT_ID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("txid", Self::VT_TXID, false)?
     .visit_field::<u32>("height", Self::VT_HEIGHT, false)?
     .visit_field::<u32>("confirmations", Self::VT_CONFIRMATIONS, false)?
     .visit_field::<u32>("timestamp", Self::VT_TIMESTAMP, false)?
     .visit_field::<i64>("amount", Self::VT_AMOUNT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("address", Self::VT_ADDRESS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("contact", Self::VT_CONTACT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("memo", Self::VT_MEMO, false)?
     .finish();
    Ok(())
  }
}
pub struct TransactionInfoArgs<'a> {
    pub id: u32,
    pub txid: Option<flatbuffers::WIPOffset<&'a str>>,
    pub height: u32,
    pub confirmations: u32,
    pub timestamp: u32,
    pub amount: i64,
    pub address: Option<flatbuffers::WIPOffset<&'a str>>,
    pub contact: Option<flatbuffers::WIPOffset<&'a str>>,
    pub memo: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for TransactionInfoArgs<'a> {
  #[inline]
  fn default() -> Self {
    TransactionInfoArgs {
      id: 0,
      txid: None,
      height: 0,
      confirmations: 0,
      timestamp: 0,
      amount: 0,
      address: None,
      contact: None,
      memo: None,
    }
  }
}

pub struct TransactionInfoBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> TransactionInfoBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_id(&mut self, id: u32) {
    self.fbb_.push_slot::<u32>(TransactionInfo::VT_ID, id, 0);
  }
  #[inline]
  pub fn add_txid(&mut self, txid: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(TransactionInfo::VT_TXID, txid);
  }
  #[inline]
  pub fn add_height(&mut self, height: u32) {
    self.fbb_.push_slot::<u32>(TransactionInfo::VT_HEIGHT, height, 0);
  }
  #[inline]
  pub fn add_confirmations(&mut self, confirmations: u32) {
    self.fbb_.push_slot::<u32>(TransactionInfo::VT_CONFIRMATIONS, confirmations, 0);
  }
  #[inline]
  pub fn add_timestamp(&mut self, timestamp: u32) {
    self.fbb_.push_slot::<u32>(TransactionInfo::VT_TIMESTAMP, timestamp, 0);
  }
  #[inline]
  pub fn add_amount(&mut self, amount: i64) {
    self.fbb_.push_slot::<i64>(TransactionInfo::VT_AMOUNT, amount, 0);
  }
  #[inline]
  pub fn add_address(&mut self, address: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(TransactionInfo::VT_ADDRESS, address);
  }
  #[inline]
  pub fn add_contact(&mut self, contact: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(TransactionInfo::VT_CONTACT, contact);
  }
  #[inline]
  pub fn add_memo(&mut self, memo: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(TransactionInfo::VT_MEMO, memo);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> TransactionInfoBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    TransactionInfoBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<TransactionInfo<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for TransactionInfo<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("TransactionInfo");
      ds.field("id", &self.id());
      ds.field("txid", &self.txid());
      ds.field("height", &self.height());
      ds.field("confirmations", &self.confirmations());
      ds.field("timestamp", &self.timestamp());
      ds.field("amount", &self.amount());
      ds.field("address", &self.address());
      ds.field("contact", &self.contact());
      ds.field("memo", &self.memo());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Serialize, Deserialize, Debug, Clone, PartialEq)]
pub struct TransactionInfoT {
  pub id: u32,
  pub txid: Option<String>,
  pub height: u32,
  pub confirmations: u32,
  pub timestamp: u32,
  pub amount: i64,
  pub address: Option<String>,
  pub contact: Option<String>,
  pub memo: Option<String>,
}
impl Default for TransactionInfoT {
  fn default() -> Self {
    Self {
      id: 0,
      txid: None,
      height: 0,
      confirmations: 0,
      timestamp: 0,
      amount: 0,
      address: None,
      contact: None,
      memo: None,
    }
  }
}
impl TransactionInfoT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<TransactionInfo<'b>> {
    let id = self.id;
    let txid = self.txid.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let height = self.height;
    let confirmations = self.confirmations;
    let timestamp = self.timestamp;
    let amount = self.amount;
    let address = self.address.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let contact = self.contact.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let memo = self.memo.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    TransactionInfo::create(_fbb, &TransactionInfoArgs{
      id,
      txid,
      height,
      confirmations,
      timestamp,
      amount,
      address,
      contact,
      memo,
    })
  }
}
pub enum TransactionInfoExtendedOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct TransactionInfoExtended<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for TransactionInfoExtended<'a> {
  type Inner = TransactionInfoExtended<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> TransactionInfoExtended<'a> {
  pub const VT_HEIGHT: flatbuffers::VOffsetT = 4;
  pub const VT_TIMESTAMP: flatbuffers::VOffsetT = 6;
  pub const VT_TXID: flatbuffers::VOffsetT = 8;
  pub const VT_TINS: flatbuffers::VOffsetT = 10;
  pub const VT_TOUTS: flatbuffers::VOffsetT = 12;
  pub const VT_SINS: flatbuffers::VOffsetT = 14;
  pub const VT_SOUTS: flatbuffers::VOffsetT = 16;
  pub const VT_OINS: flatbuffers::VOffsetT = 18;
  pub const VT_OOUTS: flatbuffers::VOffsetT = 20;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    TransactionInfoExtended { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args TransactionInfoExtendedArgs<'args>
  ) -> flatbuffers::WIPOffset<TransactionInfoExtended<'bldr>> {
    let mut builder = TransactionInfoExtendedBuilder::new(_fbb);
    if let Some(x) = args.oouts { builder.add_oouts(x); }
    if let Some(x) = args.oins { builder.add_oins(x); }
    if let Some(x) = args.souts { builder.add_souts(x); }
    if let Some(x) = args.sins { builder.add_sins(x); }
    if let Some(x) = args.touts { builder.add_touts(x); }
    if let Some(x) = args.tins { builder.add_tins(x); }
    if let Some(x) = args.txid { builder.add_txid(x); }
    builder.add_timestamp(args.timestamp);
    builder.add_height(args.height);
    builder.finish()
  }

  pub fn unpack(&self) -> TransactionInfoExtendedT {
    let height = self.height();
    let timestamp = self.timestamp();
    let txid = self.txid().map(|x| {
      x.into_iter().collect()
    });
    let tins = self.tins().map(|x| {
      x.iter().map(|t| t.unpack()).collect()
    });
    let touts = self.touts().map(|x| {
      x.iter().map(|t| t.unpack()).collect()
    });
    let sins = self.sins().map(|x| {
      x.iter().map(|t| t.unpack()).collect()
    });
    let souts = self.souts().map(|x| {
      x.iter().map(|t| t.unpack()).collect()
    });
    let oins = self.oins().map(|x| {
      x.iter().map(|t| t.unpack()).collect()
    });
    let oouts = self.oouts().map(|x| {
      x.iter().map(|t| t.unpack()).collect()
    });
    TransactionInfoExtendedT {
      height,
      timestamp,
      txid,
      tins,
      touts,
      sins,
      souts,
      oins,
      oouts,
    }
  }

  #[inline]
  pub fn height(&self) -> u32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u32>(TransactionInfoExtended::VT_HEIGHT, Some(0)).unwrap()}
  }
  #[inline]
  pub fn timestamp(&self) -> u32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u32>(TransactionInfoExtended::VT_TIMESTAMP, Some(0)).unwrap()}
  }
  #[inline]
  pub fn txid(&self) -> Option<flatbuffers::Vector<'a, u8>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(TransactionInfoExtended::VT_TXID, None)}
  }
  #[inline]
  pub fn tins(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<InputTransparent<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<InputTransparent>>>>(TransactionInfoExtended::VT_TINS, None)}
  }
  #[inline]
  pub fn touts(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<OutputTransparent<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<OutputTransparent>>>>(TransactionInfoExtended::VT_TOUTS, None)}
  }
  #[inline]
  pub fn sins(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<InputShielded<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<InputShielded>>>>(TransactionInfoExtended::VT_SINS, None)}
  }
  #[inline]
  pub fn souts(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<OutputShielded<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<OutputShielded>>>>(TransactionInfoExtended::VT_SOUTS, None)}
  }
  #[inline]
  pub fn oins(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<InputShielded<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<InputShielded>>>>(TransactionInfoExtended::VT_OINS, None)}
  }
  #[inline]
  pub fn oouts(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<OutputShielded<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<OutputShielded>>>>(TransactionInfoExtended::VT_OOUTS, None)}
  }
}

impl flatbuffers::Verifiable for TransactionInfoExtended<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<u32>("height", Self::VT_HEIGHT, false)?
     .visit_field::<u32>("timestamp", Self::VT_TIMESTAMP, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>("txid", Self::VT_TXID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<InputTransparent>>>>("tins", Self::VT_TINS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<OutputTransparent>>>>("touts", Self::VT_TOUTS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<InputShielded>>>>("sins", Self::VT_SINS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<OutputShielded>>>>("souts", Self::VT_SOUTS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<InputShielded>>>>("oins", Self::VT_OINS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<OutputShielded>>>>("oouts", Self::VT_OOUTS, false)?
     .finish();
    Ok(())
  }
}
pub struct TransactionInfoExtendedArgs<'a> {
    pub height: u32,
    pub timestamp: u32,
    pub txid: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
    pub tins: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<InputTransparent<'a>>>>>,
    pub touts: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<OutputTransparent<'a>>>>>,
    pub sins: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<InputShielded<'a>>>>>,
    pub souts: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<OutputShielded<'a>>>>>,
    pub oins: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<InputShielded<'a>>>>>,
    pub oouts: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<OutputShielded<'a>>>>>,
}
impl<'a> Default for TransactionInfoExtendedArgs<'a> {
  #[inline]
  fn default() -> Self {
    TransactionInfoExtendedArgs {
      height: 0,
      timestamp: 0,
      txid: None,
      tins: None,
      touts: None,
      sins: None,
      souts: None,
      oins: None,
      oouts: None,
    }
  }
}

pub struct TransactionInfoExtendedBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> TransactionInfoExtendedBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_height(&mut self, height: u32) {
    self.fbb_.push_slot::<u32>(TransactionInfoExtended::VT_HEIGHT, height, 0);
  }
  #[inline]
  pub fn add_timestamp(&mut self, timestamp: u32) {
    self.fbb_.push_slot::<u32>(TransactionInfoExtended::VT_TIMESTAMP, timestamp, 0);
  }
  #[inline]
  pub fn add_txid(&mut self, txid: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(TransactionInfoExtended::VT_TXID, txid);
  }
  #[inline]
  pub fn add_tins(&mut self, tins: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<InputTransparent<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(TransactionInfoExtended::VT_TINS, tins);
  }
  #[inline]
  pub fn add_touts(&mut self, touts: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<OutputTransparent<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(TransactionInfoExtended::VT_TOUTS, touts);
  }
  #[inline]
  pub fn add_sins(&mut self, sins: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<InputShielded<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(TransactionInfoExtended::VT_SINS, sins);
  }
  #[inline]
  pub fn add_souts(&mut self, souts: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<OutputShielded<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(TransactionInfoExtended::VT_SOUTS, souts);
  }
  #[inline]
  pub fn add_oins(&mut self, oins: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<InputShielded<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(TransactionInfoExtended::VT_OINS, oins);
  }
  #[inline]
  pub fn add_oouts(&mut self, oouts: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<OutputShielded<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(TransactionInfoExtended::VT_OOUTS, oouts);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> TransactionInfoExtendedBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    TransactionInfoExtendedBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<TransactionInfoExtended<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for TransactionInfoExtended<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("TransactionInfoExtended");
      ds.field("height", &self.height());
      ds.field("timestamp", &self.timestamp());
      ds.field("txid", &self.txid());
      ds.field("tins", &self.tins());
      ds.field("touts", &self.touts());
      ds.field("sins", &self.sins());
      ds.field("souts", &self.souts());
      ds.field("oins", &self.oins());
      ds.field("oouts", &self.oouts());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Serialize, Deserialize, Debug, Clone, PartialEq)]
pub struct TransactionInfoExtendedT {
  pub height: u32,
  pub timestamp: u32,
  pub txid: Option<Vec<u8>>,
  pub tins: Option<Vec<InputTransparentT>>,
  pub touts: Option<Vec<OutputTransparentT>>,
  pub sins: Option<Vec<InputShieldedT>>,
  pub souts: Option<Vec<OutputShieldedT>>,
  pub oins: Option<Vec<InputShieldedT>>,
  pub oouts: Option<Vec<OutputShieldedT>>,
}
impl Default for TransactionInfoExtendedT {
  fn default() -> Self {
    Self {
      height: 0,
      timestamp: 0,
      txid: None,
      tins: None,
      touts: None,
      sins: None,
      souts: None,
      oins: None,
      oouts: None,
    }
  }
}
impl TransactionInfoExtendedT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<TransactionInfoExtended<'b>> {
    let height = self.height;
    let timestamp = self.timestamp;
    let txid = self.txid.as_ref().map(|x|{
      _fbb.create_vector(x)
    });
    let tins = self.tins.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();_fbb.create_vector(&w)
    });
    let touts = self.touts.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();_fbb.create_vector(&w)
    });
    let sins = self.sins.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();_fbb.create_vector(&w)
    });
    let souts = self.souts.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();_fbb.create_vector(&w)
    });
    let oins = self.oins.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();_fbb.create_vector(&w)
    });
    let oouts = self.oouts.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();_fbb.create_vector(&w)
    });
    TransactionInfoExtended::create(_fbb, &TransactionInfoExtendedArgs{
      height,
      timestamp,
      txid,
      tins,
      touts,
      sins,
      souts,
      oins,
      oouts,
    })
  }
}
pub enum InputTransparentOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct InputTransparent<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for InputTransparent<'a> {
  type Inner = InputTransparent<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> InputTransparent<'a> {
  pub const VT_TXID: flatbuffers::VOffsetT = 4;
  pub const VT_VOUT: flatbuffers::VOffsetT = 6;
  pub const VT_ADDRESS: flatbuffers::VOffsetT = 8;
  pub const VT_VALUE: flatbuffers::VOffsetT = 10;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    InputTransparent { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args InputTransparentArgs<'args>
  ) -> flatbuffers::WIPOffset<InputTransparent<'bldr>> {
    let mut builder = InputTransparentBuilder::new(_fbb);
    builder.add_value(args.value);
    if let Some(x) = args.address { builder.add_address(x); }
    builder.add_vout(args.vout);
    if let Some(x) = args.txid { builder.add_txid(x); }
    builder.finish()
  }

  pub fn unpack(&self) -> InputTransparentT {
    let txid = self.txid().map(|x| {
      x.into_iter().collect()
    });
    let vout = self.vout();
    let address = self.address().map(|x| {
      x.to_string()
    });
    let value = self.value();
    InputTransparentT {
      txid,
      vout,
      address,
      value,
    }
  }

  #[inline]
  pub fn txid(&self) -> Option<flatbuffers::Vector<'a, u8>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(InputTransparent::VT_TXID, None)}
  }
  #[inline]
  pub fn vout(&self) -> u32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u32>(InputTransparent::VT_VOUT, Some(0)).unwrap()}
  }
  #[inline]
  pub fn address(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(InputTransparent::VT_ADDRESS, None)}
  }
  #[inline]
  pub fn value(&self) -> u64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u64>(InputTransparent::VT_VALUE, Some(0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for InputTransparent<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>("txid", Self::VT_TXID, false)?
     .visit_field::<u32>("vout", Self::VT_VOUT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("address", Self::VT_ADDRESS, false)?
     .visit_field::<u64>("value", Self::VT_VALUE, false)?
     .finish();
    Ok(())
  }
}
pub struct InputTransparentArgs<'a> {
    pub txid: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
    pub vout: u32,
    pub address: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: u64,
}
impl<'a> Default for InputTransparentArgs<'a> {
  #[inline]
  fn default() -> Self {
    InputTransparentArgs {
      txid: None,
      vout: 0,
      address: None,
      value: 0,
    }
  }
}

pub struct InputTransparentBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> InputTransparentBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_txid(&mut self, txid: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(InputTransparent::VT_TXID, txid);
  }
  #[inline]
  pub fn add_vout(&mut self, vout: u32) {
    self.fbb_.push_slot::<u32>(InputTransparent::VT_VOUT, vout, 0);
  }
  #[inline]
  pub fn add_address(&mut self, address: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(InputTransparent::VT_ADDRESS, address);
  }
  #[inline]
  pub fn add_value(&mut self, value: u64) {
    self.fbb_.push_slot::<u64>(InputTransparent::VT_VALUE, value, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> InputTransparentBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    InputTransparentBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<InputTransparent<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for InputTransparent<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("InputTransparent");
      ds.field("txid", &self.txid());
      ds.field("vout", &self.vout());
      ds.field("address", &self.address());
      ds.field("value", &self.value());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Serialize, Deserialize, Debug, Clone, PartialEq)]
pub struct InputTransparentT {
  pub txid: Option<Vec<u8>>,
  pub vout: u32,
  pub address: Option<String>,
  pub value: u64,
}
impl Default for InputTransparentT {
  fn default() -> Self {
    Self {
      txid: None,
      vout: 0,
      address: None,
      value: 0,
    }
  }
}
impl InputTransparentT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<InputTransparent<'b>> {
    let txid = self.txid.as_ref().map(|x|{
      _fbb.create_vector(x)
    });
    let vout = self.vout;
    let address = self.address.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let value = self.value;
    InputTransparent::create(_fbb, &InputTransparentArgs{
      txid,
      vout,
      address,
      value,
    })
  }
}
pub enum OutputTransparentOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct OutputTransparent<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for OutputTransparent<'a> {
  type Inner = OutputTransparent<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> OutputTransparent<'a> {
  pub const VT_ADDRESS: flatbuffers::VOffsetT = 4;
  pub const VT_VALUE: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    OutputTransparent { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args OutputTransparentArgs<'args>
  ) -> flatbuffers::WIPOffset<OutputTransparent<'bldr>> {
    let mut builder = OutputTransparentBuilder::new(_fbb);
    builder.add_value(args.value);
    if let Some(x) = args.address { builder.add_address(x); }
    builder.finish()
  }

  pub fn unpack(&self) -> OutputTransparentT {
    let address = self.address().map(|x| {
      x.to_string()
    });
    let value = self.value();
    OutputTransparentT {
      address,
      value,
    }
  }

  #[inline]
  pub fn address(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(OutputTransparent::VT_ADDRESS, None)}
  }
  #[inline]
  pub fn value(&self) -> u64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u64>(OutputTransparent::VT_VALUE, Some(0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for OutputTransparent<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("address", Self::VT_ADDRESS, false)?
     .visit_field::<u64>("value", Self::VT_VALUE, false)?
     .finish();
    Ok(())
  }
}
pub struct OutputTransparentArgs<'a> {
    pub address: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: u64,
}
impl<'a> Default for OutputTransparentArgs<'a> {
  #[inline]
  fn default() -> Self {
    OutputTransparentArgs {
      address: None,
      value: 0,
    }
  }
}

pub struct OutputTransparentBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> OutputTransparentBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_address(&mut self, address: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(OutputTransparent::VT_ADDRESS, address);
  }
  #[inline]
  pub fn add_value(&mut self, value: u64) {
    self.fbb_.push_slot::<u64>(OutputTransparent::VT_VALUE, value, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> OutputTransparentBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    OutputTransparentBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<OutputTransparent<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for OutputTransparent<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("OutputTransparent");
      ds.field("address", &self.address());
      ds.field("value", &self.value());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Serialize, Deserialize, Debug, Clone, PartialEq)]
pub struct OutputTransparentT {
  pub address: Option<String>,
  pub value: u64,
}
impl Default for OutputTransparentT {
  fn default() -> Self {
    Self {
      address: None,
      value: 0,
    }
  }
}
impl OutputTransparentT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<OutputTransparent<'b>> {
    let address = self.address.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let value = self.value;
    OutputTransparent::create(_fbb, &OutputTransparentArgs{
      address,
      value,
    })
  }
}
pub enum InputShieldedOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct InputShielded<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for InputShielded<'a> {
  type Inner = InputShielded<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> InputShielded<'a> {
  pub const VT_NF: flatbuffers::VOffsetT = 4;
  pub const VT_ADDRESS: flatbuffers::VOffsetT = 6;
  pub const VT_VALUE: flatbuffers::VOffsetT = 8;
  pub const VT_RCM: flatbuffers::VOffsetT = 10;
  pub const VT_RHO: flatbuffers::VOffsetT = 12;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    InputShielded { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args InputShieldedArgs<'args>
  ) -> flatbuffers::WIPOffset<InputShielded<'bldr>> {
    let mut builder = InputShieldedBuilder::new(_fbb);
    builder.add_value(args.value);
    if let Some(x) = args.rho { builder.add_rho(x); }
    if let Some(x) = args.rcm { builder.add_rcm(x); }
    if let Some(x) = args.address { builder.add_address(x); }
    if let Some(x) = args.nf { builder.add_nf(x); }
    builder.finish()
  }

  pub fn unpack(&self) -> InputShieldedT {
    let nf = self.nf().map(|x| {
      x.into_iter().collect()
    });
    let address = self.address().map(|x| {
      x.to_string()
    });
    let value = self.value();
    let rcm = self.rcm().map(|x| {
      x.into_iter().collect()
    });
    let rho = self.rho().map(|x| {
      x.into_iter().collect()
    });
    InputShieldedT {
      nf,
      address,
      value,
      rcm,
      rho,
    }
  }

  #[inline]
  pub fn nf(&self) -> Option<flatbuffers::Vector<'a, u8>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(InputShielded::VT_NF, None)}
  }
  #[inline]
  pub fn address(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(InputShielded::VT_ADDRESS, None)}
  }
  #[inline]
  pub fn value(&self) -> u64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u64>(InputShielded::VT_VALUE, Some(0)).unwrap()}
  }
  #[inline]
  pub fn rcm(&self) -> Option<flatbuffers::Vector<'a, u8>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(InputShielded::VT_RCM, None)}
  }
  #[inline]
  pub fn rho(&self) -> Option<flatbuffers::Vector<'a, u8>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(InputShielded::VT_RHO, None)}
  }
}

impl flatbuffers::Verifiable for InputShielded<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>("nf", Self::VT_NF, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("address", Self::VT_ADDRESS, false)?
     .visit_field::<u64>("value", Self::VT_VALUE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>("rcm", Self::VT_RCM, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>("rho", Self::VT_RHO, false)?
     .finish();
    Ok(())
  }
}
pub struct InputShieldedArgs<'a> {
    pub nf: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
    pub address: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: u64,
    pub rcm: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
    pub rho: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
}
impl<'a> Default for InputShieldedArgs<'a> {
  #[inline]
  fn default() -> Self {
    InputShieldedArgs {
      nf: None,
      address: None,
      value: 0,
      rcm: None,
      rho: None,
    }
  }
}

pub struct InputShieldedBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> InputShieldedBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_nf(&mut self, nf: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(InputShielded::VT_NF, nf);
  }
  #[inline]
  pub fn add_address(&mut self, address: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(InputShielded::VT_ADDRESS, address);
  }
  #[inline]
  pub fn add_value(&mut self, value: u64) {
    self.fbb_.push_slot::<u64>(InputShielded::VT_VALUE, value, 0);
  }
  #[inline]
  pub fn add_rcm(&mut self, rcm: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(InputShielded::VT_RCM, rcm);
  }
  #[inline]
  pub fn add_rho(&mut self, rho: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(InputShielded::VT_RHO, rho);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> InputShieldedBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    InputShieldedBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<InputShielded<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for InputShielded<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("InputShielded");
      ds.field("nf", &self.nf());
      ds.field("address", &self.address());
      ds.field("value", &self.value());
      ds.field("rcm", &self.rcm());
      ds.field("rho", &self.rho());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Serialize, Deserialize, Debug, Clone, PartialEq)]
pub struct InputShieldedT {
  pub nf: Option<Vec<u8>>,
  pub address: Option<String>,
  pub value: u64,
  pub rcm: Option<Vec<u8>>,
  pub rho: Option<Vec<u8>>,
}
impl Default for InputShieldedT {
  fn default() -> Self {
    Self {
      nf: None,
      address: None,
      value: 0,
      rcm: None,
      rho: None,
    }
  }
}
impl InputShieldedT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<InputShielded<'b>> {
    let nf = self.nf.as_ref().map(|x|{
      _fbb.create_vector(x)
    });
    let address = self.address.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let value = self.value;
    let rcm = self.rcm.as_ref().map(|x|{
      _fbb.create_vector(x)
    });
    let rho = self.rho.as_ref().map(|x|{
      _fbb.create_vector(x)
    });
    InputShielded::create(_fbb, &InputShieldedArgs{
      nf,
      address,
      value,
      rcm,
      rho,
    })
  }
}
pub enum OutputShieldedOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct OutputShielded<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for OutputShielded<'a> {
  type Inner = OutputShielded<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> OutputShielded<'a> {
  pub const VT_INCOMING: flatbuffers::VOffsetT = 4;
  pub const VT_CMX: flatbuffers::VOffsetT = 6;
  pub const VT_ADDRESS: flatbuffers::VOffsetT = 8;
  pub const VT_VALUE: flatbuffers::VOffsetT = 10;
  pub const VT_RCM: flatbuffers::VOffsetT = 12;
  pub const VT_RHO: flatbuffers::VOffsetT = 14;
  pub const VT_MEMO: flatbuffers::VOffsetT = 16;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    OutputShielded { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args OutputShieldedArgs<'args>
  ) -> flatbuffers::WIPOffset<OutputShielded<'bldr>> {
    let mut builder = OutputShieldedBuilder::new(_fbb);
    builder.add_value(args.value);
    if let Some(x) = args.memo { builder.add_memo(x); }
    if let Some(x) = args.rho { builder.add_rho(x); }
    if let Some(x) = args.rcm { builder.add_rcm(x); }
    if let Some(x) = args.address { builder.add_address(x); }
    if let Some(x) = args.cmx { builder.add_cmx(x); }
    builder.add_incoming(args.incoming);
    builder.finish()
  }

  pub fn unpack(&self) -> OutputShieldedT {
    let incoming = self.incoming();
    let cmx = self.cmx().map(|x| {
      x.into_iter().collect()
    });
    let address = self.address().map(|x| {
      x.to_string()
    });
    let value = self.value();
    let rcm = self.rcm().map(|x| {
      x.into_iter().collect()
    });
    let rho = self.rho().map(|x| {
      x.into_iter().collect()
    });
    let memo = self.memo().map(|x| {
      x.to_string()
    });
    OutputShieldedT {
      incoming,
      cmx,
      address,
      value,
      rcm,
      rho,
      memo,
    }
  }

  #[inline]
  pub fn incoming(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(OutputShielded::VT_INCOMING, Some(false)).unwrap()}
  }
  #[inline]
  pub fn cmx(&self) -> Option<flatbuffers::Vector<'a, u8>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(OutputShielded::VT_CMX, None)}
  }
  #[inline]
  pub fn address(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(OutputShielded::VT_ADDRESS, None)}
  }
  #[inline]
  pub fn value(&self) -> u64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u64>(OutputShielded::VT_VALUE, Some(0)).unwrap()}
  }
  #[inline]
  pub fn rcm(&self) -> Option<flatbuffers::Vector<'a, u8>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(OutputShielded::VT_RCM, None)}
  }
  #[inline]
  pub fn rho(&self) -> Option<flatbuffers::Vector<'a, u8>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(OutputShielded::VT_RHO, None)}
  }
  #[inline]
  pub fn memo(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(OutputShielded::VT_MEMO, None)}
  }
}

impl flatbuffers::Verifiable for OutputShielded<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<bool>("incoming", Self::VT_INCOMING, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>("cmx", Self::VT_CMX, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("address", Self::VT_ADDRESS, false)?
     .visit_field::<u64>("value", Self::VT_VALUE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>("rcm", Self::VT_RCM, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>("rho", Self::VT_RHO, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("memo", Self::VT_MEMO, false)?
     .finish();
    Ok(())
  }
}
pub struct OutputShieldedArgs<'a> {
    pub incoming: bool,
    pub cmx: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
    pub address: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: u64,
    pub rcm: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
    pub rho: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
    pub memo: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for OutputShieldedArgs<'a> {
  #[inline]
  fn default() -> Self {
    OutputShieldedArgs {
      incoming: false,
      cmx: None,
      address: None,
      value: 0,
      rcm: None,
      rho: None,
      memo: None,
    }
  }
}

pub struct OutputShieldedBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> OutputShieldedBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_incoming(&mut self, incoming: bool) {
    self.fbb_.push_slot::<bool>(OutputShielded::VT_INCOMING, incoming, false);
  }
  #[inline]
  pub fn add_cmx(&mut self, cmx: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(OutputShielded::VT_CMX, cmx);
  }
  #[inline]
  pub fn add_address(&mut self, address: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(OutputShielded::VT_ADDRESS, address);
  }
  #[inline]
  pub fn add_value(&mut self, value: u64) {
    self.fbb_.push_slot::<u64>(OutputShielded::VT_VALUE, value, 0);
  }
  #[inline]
  pub fn add_rcm(&mut self, rcm: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(OutputShielded::VT_RCM, rcm);
  }
  #[inline]
  pub fn add_rho(&mut self, rho: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(OutputShielded::VT_RHO, rho);
  }
  #[inline]
  pub fn add_memo(&mut self, memo: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(OutputShielded::VT_MEMO, memo);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> OutputShieldedBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    OutputShieldedBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<OutputShielded<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for OutputShielded<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("OutputShielded");
      ds.field("incoming", &self.incoming());
      ds.field("cmx", &self.cmx());
      ds.field("address", &self.address());
      ds.field("value", &self.value());
      ds.field("rcm", &self.rcm());
      ds.field("rho", &self.rho());
      ds.field("memo", &self.memo());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Serialize, Deserialize, Debug, Clone, PartialEq)]
pub struct OutputShieldedT {
  pub incoming: bool,
  pub cmx: Option<Vec<u8>>,
  pub address: Option<String>,
  pub value: u64,
  pub rcm: Option<Vec<u8>>,
  pub rho: Option<Vec<u8>>,
  pub memo: Option<String>,
}
impl Default for OutputShieldedT {
  fn default() -> Self {
    Self {
      incoming: false,
      cmx: None,
      address: None,
      value: 0,
      rcm: None,
      rho: None,
      memo: None,
    }
  }
}
impl OutputShieldedT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<OutputShielded<'b>> {
    let incoming = self.incoming;
    let cmx = self.cmx.as_ref().map(|x|{
      _fbb.create_vector(x)
    });
    let address = self.address.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let value = self.value;
    let rcm = self.rcm.as_ref().map(|x|{
      _fbb.create_vector(x)
    });
    let rho = self.rho.as_ref().map(|x|{
      _fbb.create_vector(x)
    });
    let memo = self.memo.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    OutputShielded::create(_fbb, &OutputShieldedArgs{
      incoming,
      cmx,
      address,
      value,
      rcm,
      rho,
      memo,
    })
  }
}
pub enum ShieldedNoteOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct ShieldedNote<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ShieldedNote<'a> {
  type Inner = ShieldedNote<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> ShieldedNote<'a> {
  pub const VT_HEIGHT: flatbuffers::VOffsetT = 4;
  pub const VT_CONFIRMATIONS: flatbuffers::VOffsetT = 6;
  pub const VT_TIMESTAMP: flatbuffers::VOffsetT = 8;
  pub const VT_VALUE: flatbuffers::VOffsetT = 10;
  pub const VT_ORCHARD: flatbuffers::VOffsetT = 12;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    ShieldedNote { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args ShieldedNoteArgs
  ) -> flatbuffers::WIPOffset<ShieldedNote<'bldr>> {
    let mut builder = ShieldedNoteBuilder::new(_fbb);
    builder.add_value(args.value);
    builder.add_timestamp(args.timestamp);
    builder.add_confirmations(args.confirmations);
    builder.add_height(args.height);
    builder.add_orchard(args.orchard);
    builder.finish()
  }

  pub fn unpack(&self) -> ShieldedNoteT {
    let height = self.height();
    let confirmations = self.confirmations();
    let timestamp = self.timestamp();
    let value = self.value();
    let orchard = self.orchard();
    ShieldedNoteT {
      height,
      confirmations,
      timestamp,
      value,
      orchard,
    }
  }

  #[inline]
  pub fn height(&self) -> u32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u32>(ShieldedNote::VT_HEIGHT, Some(0)).unwrap()}
  }
  #[inline]
  pub fn confirmations(&self) -> u32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u32>(ShieldedNote::VT_CONFIRMATIONS, Some(0)).unwrap()}
  }
  #[inline]
  pub fn timestamp(&self) -> u32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u32>(ShieldedNote::VT_TIMESTAMP, Some(0)).unwrap()}
  }
  #[inline]
  pub fn value(&self) -> u64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u64>(ShieldedNote::VT_VALUE, Some(0)).unwrap()}
  }
  #[inline]
  pub fn orchard(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(ShieldedNote::VT_ORCHARD, Some(false)).unwrap()}
  }
}

impl flatbuffers::Verifiable for ShieldedNote<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<u32>("height", Self::VT_HEIGHT, false)?
     .visit_field::<u32>("confirmations", Self::VT_CONFIRMATIONS, false)?
     .visit_field::<u32>("timestamp", Self::VT_TIMESTAMP, false)?
     .visit_field::<u64>("value", Self::VT_VALUE, false)?
     .visit_field::<bool>("orchard", Self::VT_ORCHARD, false)?
     .finish();
    Ok(())
  }
}
pub struct ShieldedNoteArgs {
    pub height: u32,
    pub confirmations: u32,
    pub timestamp: u32,
    pub value: u64,
    pub orchard: bool,
}
impl<'a> Default for ShieldedNoteArgs {
  #[inline]
  fn default() -> Self {
    ShieldedNoteArgs {
      height: 0,
      confirmations: 0,
      timestamp: 0,
      value: 0,
      orchard: false,
    }
  }
}

pub struct ShieldedNoteBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> ShieldedNoteBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_height(&mut self, height: u32) {
    self.fbb_.push_slot::<u32>(ShieldedNote::VT_HEIGHT, height, 0);
  }
  #[inline]
  pub fn add_confirmations(&mut self, confirmations: u32) {
    self.fbb_.push_slot::<u32>(ShieldedNote::VT_CONFIRMATIONS, confirmations, 0);
  }
  #[inline]
  pub fn add_timestamp(&mut self, timestamp: u32) {
    self.fbb_.push_slot::<u32>(ShieldedNote::VT_TIMESTAMP, timestamp, 0);
  }
  #[inline]
  pub fn add_value(&mut self, value: u64) {
    self.fbb_.push_slot::<u64>(ShieldedNote::VT_VALUE, value, 0);
  }
  #[inline]
  pub fn add_orchard(&mut self, orchard: bool) {
    self.fbb_.push_slot::<bool>(ShieldedNote::VT_ORCHARD, orchard, false);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> ShieldedNoteBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    ShieldedNoteBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<ShieldedNote<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for ShieldedNote<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("ShieldedNote");
      ds.field("height", &self.height());
      ds.field("confirmations", &self.confirmations());
      ds.field("timestamp", &self.timestamp());
      ds.field("value", &self.value());
      ds.field("orchard", &self.orchard());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Serialize, Deserialize, Debug, Clone, PartialEq)]
pub struct ShieldedNoteT {
  pub height: u32,
  pub confirmations: u32,
  pub timestamp: u32,
  pub value: u64,
  pub orchard: bool,
}
impl Default for ShieldedNoteT {
  fn default() -> Self {
    Self {
      height: 0,
      confirmations: 0,
      timestamp: 0,
      value: 0,
      orchard: false,
    }
  }
}
impl ShieldedNoteT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<ShieldedNote<'b>> {
    let height = self.height;
    let confirmations = self.confirmations;
    let timestamp = self.timestamp;
    let value = self.value;
    let orchard = self.orchard;
    ShieldedNote::create(_fbb, &ShieldedNoteArgs{
      height,
      confirmations,
      timestamp,
      value,
      orchard,
    })
  }
}
pub enum ShieldedMessageOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct ShieldedMessage<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ShieldedMessage<'a> {
  type Inner = ShieldedMessage<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> ShieldedMessage<'a> {
  pub const VT_ID_MSG: flatbuffers::VOffsetT = 4;
  pub const VT_ID_TX: flatbuffers::VOffsetT = 6;
  pub const VT_TXID: flatbuffers::VOffsetT = 8;
  pub const VT_HEIGHT: flatbuffers::VOffsetT = 10;
  pub const VT_TIMESTAMP: flatbuffers::VOffsetT = 12;
  pub const VT_INCOMING: flatbuffers::VOffsetT = 14;
  pub const VT_NOUT: flatbuffers::VOffsetT = 16;
  pub const VT_SENDER: flatbuffers::VOffsetT = 18;
  pub const VT_RECIPIENT: flatbuffers::VOffsetT = 20;
  pub const VT_SUBJECT: flatbuffers::VOffsetT = 22;
  pub const VT_BODY: flatbuffers::VOffsetT = 24;
  pub const VT_READ: flatbuffers::VOffsetT = 26;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    ShieldedMessage { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args ShieldedMessageArgs<'args>
  ) -> flatbuffers::WIPOffset<ShieldedMessage<'bldr>> {
    let mut builder = ShieldedMessageBuilder::new(_fbb);
    if let Some(x) = args.body { builder.add_body(x); }
    if let Some(x) = args.subject { builder.add_subject(x); }
    if let Some(x) = args.recipient { builder.add_recipient(x); }
    if let Some(x) = args.sender { builder.add_sender(x); }
    builder.add_nout(args.nout);
    builder.add_timestamp(args.timestamp);
    builder.add_height(args.height);
    if let Some(x) = args.txid { builder.add_txid(x); }
    builder.add_id_tx(args.id_tx);
    builder.add_id_msg(args.id_msg);
    builder.add_read(args.read);
    builder.add_incoming(args.incoming);
    builder.finish()
  }

  pub fn unpack(&self) -> ShieldedMessageT {
    let id_msg = self.id_msg();
    let id_tx = self.id_tx();
    let txid = self.txid().map(|x| {
      x.into_iter().collect()
    });
    let height = self.height();
    let timestamp = self.timestamp();
    let incoming = self.incoming();
    let nout = self.nout();
    let sender = self.sender().map(|x| {
      x.to_string()
    });
    let recipient = self.recipient().map(|x| {
      x.to_string()
    });
    let subject = self.subject().map(|x| {
      x.to_string()
    });
    let body = self.body().map(|x| {
      x.to_string()
    });
    let read = self.read();
    ShieldedMessageT {
      id_msg,
      id_tx,
      txid,
      height,
      timestamp,
      incoming,
      nout,
      sender,
      recipient,
      subject,
      body,
      read,
    }
  }

  #[inline]
  pub fn id_msg(&self) -> u32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u32>(ShieldedMessage::VT_ID_MSG, Some(0)).unwrap()}
  }
  #[inline]
  pub fn id_tx(&self) -> u32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u32>(ShieldedMessage::VT_ID_TX, Some(0)).unwrap()}
  }
  #[inline]
  pub fn txid(&self) -> Option<flatbuffers::Vector<'a, u8>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(ShieldedMessage::VT_TXID, None)}
  }
  #[inline]
  pub fn height(&self) -> u32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u32>(ShieldedMessage::VT_HEIGHT, Some(0)).unwrap()}
  }
  #[inline]
  pub fn timestamp(&self) -> u32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u32>(ShieldedMessage::VT_TIMESTAMP, Some(0)).unwrap()}
  }
  #[inline]
  pub fn incoming(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(ShieldedMessage::VT_INCOMING, Some(false)).unwrap()}
  }
  #[inline]
  pub fn nout(&self) -> u32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u32>(ShieldedMessage::VT_NOUT, Some(0)).unwrap()}
  }
  #[inline]
  pub fn sender(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(ShieldedMessage::VT_SENDER, None)}
  }
  #[inline]
  pub fn recipient(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(ShieldedMessage::VT_RECIPIENT, None)}
  }
  #[inline]
  pub fn subject(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(ShieldedMessage::VT_SUBJECT, None)}
  }
  #[inline]
  pub fn body(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(ShieldedMessage::VT_BODY, None)}
  }
  #[inline]
  pub fn read(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(ShieldedMessage::VT_READ, Some(false)).unwrap()}
  }
}

impl flatbuffers::Verifiable for ShieldedMessage<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<u32>("id_msg", Self::VT_ID_MSG, false)?
     .visit_field::<u32>("id_tx", Self::VT_ID_TX, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>("txid", Self::VT_TXID, false)?
     .visit_field::<u32>("height", Self::VT_HEIGHT, false)?
     .visit_field::<u32>("timestamp", Self::VT_TIMESTAMP, false)?
     .visit_field::<bool>("incoming", Self::VT_INCOMING, false)?
     .visit_field::<u32>("nout", Self::VT_NOUT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("sender", Self::VT_SENDER, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("recipient", Self::VT_RECIPIENT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("subject", Self::VT_SUBJECT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("body", Self::VT_BODY, false)?
     .visit_field::<bool>("read", Self::VT_READ, false)?
     .finish();
    Ok(())
  }
}
pub struct ShieldedMessageArgs<'a> {
    pub id_msg: u32,
    pub id_tx: u32,
    pub txid: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
    pub height: u32,
    pub timestamp: u32,
    pub incoming: bool,
    pub nout: u32,
    pub sender: Option<flatbuffers::WIPOffset<&'a str>>,
    pub recipient: Option<flatbuffers::WIPOffset<&'a str>>,
    pub subject: Option<flatbuffers::WIPOffset<&'a str>>,
    pub body: Option<flatbuffers::WIPOffset<&'a str>>,
    pub read: bool,
}
impl<'a> Default for ShieldedMessageArgs<'a> {
  #[inline]
  fn default() -> Self {
    ShieldedMessageArgs {
      id_msg: 0,
      id_tx: 0,
      txid: None,
      height: 0,
      timestamp: 0,
      incoming: false,
      nout: 0,
      sender: None,
      recipient: None,
      subject: None,
      body: None,
      read: false,
    }
  }
}

pub struct ShieldedMessageBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> ShieldedMessageBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_id_msg(&mut self, id_msg: u32) {
    self.fbb_.push_slot::<u32>(ShieldedMessage::VT_ID_MSG, id_msg, 0);
  }
  #[inline]
  pub fn add_id_tx(&mut self, id_tx: u32) {
    self.fbb_.push_slot::<u32>(ShieldedMessage::VT_ID_TX, id_tx, 0);
  }
  #[inline]
  pub fn add_txid(&mut self, txid: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ShieldedMessage::VT_TXID, txid);
  }
  #[inline]
  pub fn add_height(&mut self, height: u32) {
    self.fbb_.push_slot::<u32>(ShieldedMessage::VT_HEIGHT, height, 0);
  }
  #[inline]
  pub fn add_timestamp(&mut self, timestamp: u32) {
    self.fbb_.push_slot::<u32>(ShieldedMessage::VT_TIMESTAMP, timestamp, 0);
  }
  #[inline]
  pub fn add_incoming(&mut self, incoming: bool) {
    self.fbb_.push_slot::<bool>(ShieldedMessage::VT_INCOMING, incoming, false);
  }
  #[inline]
  pub fn add_nout(&mut self, nout: u32) {
    self.fbb_.push_slot::<u32>(ShieldedMessage::VT_NOUT, nout, 0);
  }
  #[inline]
  pub fn add_sender(&mut self, sender: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ShieldedMessage::VT_SENDER, sender);
  }
  #[inline]
  pub fn add_recipient(&mut self, recipient: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ShieldedMessage::VT_RECIPIENT, recipient);
  }
  #[inline]
  pub fn add_subject(&mut self, subject: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ShieldedMessage::VT_SUBJECT, subject);
  }
  #[inline]
  pub fn add_body(&mut self, body: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ShieldedMessage::VT_BODY, body);
  }
  #[inline]
  pub fn add_read(&mut self, read: bool) {
    self.fbb_.push_slot::<bool>(ShieldedMessage::VT_READ, read, false);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> ShieldedMessageBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    ShieldedMessageBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<ShieldedMessage<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for ShieldedMessage<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("ShieldedMessage");
      ds.field("id_msg", &self.id_msg());
      ds.field("id_tx", &self.id_tx());
      ds.field("txid", &self.txid());
      ds.field("height", &self.height());
      ds.field("timestamp", &self.timestamp());
      ds.field("incoming", &self.incoming());
      ds.field("nout", &self.nout());
      ds.field("sender", &self.sender());
      ds.field("recipient", &self.recipient());
      ds.field("subject", &self.subject());
      ds.field("body", &self.body());
      ds.field("read", &self.read());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Serialize, Deserialize, Debug, Clone, PartialEq)]
pub struct ShieldedMessageT {
  pub id_msg: u32,
  pub id_tx: u32,
  pub txid: Option<Vec<u8>>,
  pub height: u32,
  pub timestamp: u32,
  pub incoming: bool,
  pub nout: u32,
  pub sender: Option<String>,
  pub recipient: Option<String>,
  pub subject: Option<String>,
  pub body: Option<String>,
  pub read: bool,
}
impl Default for ShieldedMessageT {
  fn default() -> Self {
    Self {
      id_msg: 0,
      id_tx: 0,
      txid: None,
      height: 0,
      timestamp: 0,
      incoming: false,
      nout: 0,
      sender: None,
      recipient: None,
      subject: None,
      body: None,
      read: false,
    }
  }
}
impl ShieldedMessageT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<ShieldedMessage<'b>> {
    let id_msg = self.id_msg;
    let id_tx = self.id_tx;
    let txid = self.txid.as_ref().map(|x|{
      _fbb.create_vector(x)
    });
    let height = self.height;
    let timestamp = self.timestamp;
    let incoming = self.incoming;
    let nout = self.nout;
    let sender = self.sender.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let recipient = self.recipient.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let subject = self.subject.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let body = self.body.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let read = self.read;
    ShieldedMessage::create(_fbb, &ShieldedMessageArgs{
      id_msg,
      id_tx,
      txid,
      height,
      timestamp,
      incoming,
      nout,
      sender,
      recipient,
      subject,
      body,
      read,
    })
  }
}
pub enum UAReceiversOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct UAReceivers<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for UAReceivers<'a> {
  type Inner = UAReceivers<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> UAReceivers<'a> {
  pub const VT_TRANSPARENT: flatbuffers::VOffsetT = 4;
  pub const VT_SAPLING: flatbuffers::VOffsetT = 6;
  pub const VT_ORCHARD: flatbuffers::VOffsetT = 8;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    UAReceivers { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args UAReceiversArgs<'args>
  ) -> flatbuffers::WIPOffset<UAReceivers<'bldr>> {
    let mut builder = UAReceiversBuilder::new(_fbb);
    if let Some(x) = args.orchard { builder.add_orchard(x); }
    if let Some(x) = args.sapling { builder.add_sapling(x); }
    if let Some(x) = args.transparent { builder.add_transparent(x); }
    builder.finish()
  }

  pub fn unpack(&self) -> UAReceiversT {
    let transparent = self.transparent().map(|x| {
      x.to_string()
    });
    let sapling = self.sapling().map(|x| {
      x.to_string()
    });
    let orchard = self.orchard().map(|x| {
      x.to_string()
    });
    UAReceiversT {
      transparent,
      sapling,
      orchard,
    }
  }

  #[inline]
  pub fn transparent(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(UAReceivers::VT_TRANSPARENT, None)}
  }
  #[inline]
  pub fn sapling(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(UAReceivers::VT_SAPLING, None)}
  }
  #[inline]
  pub fn orchard(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(UAReceivers::VT_ORCHARD, None)}
  }
}

impl flatbuffers::Verifiable for UAReceivers<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("transparent", Self::VT_TRANSPARENT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("sapling", Self::VT_SAPLING, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("orchard", Self::VT_ORCHARD, false)?
     .finish();
    Ok(())
  }
}
pub struct UAReceiversArgs<'a> {
    pub transparent: Option<flatbuffers::WIPOffset<&'a str>>,
    pub sapling: Option<flatbuffers::WIPOffset<&'a str>>,
    pub orchard: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for UAReceiversArgs<'a> {
  #[inline]
  fn default() -> Self {
    UAReceiversArgs {
      transparent: None,
      sapling: None,
      orchard: None,
    }
  }
}

pub struct UAReceiversBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> UAReceiversBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_transparent(&mut self, transparent: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(UAReceivers::VT_TRANSPARENT, transparent);
  }
  #[inline]
  pub fn add_sapling(&mut self, sapling: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(UAReceivers::VT_SAPLING, sapling);
  }
  #[inline]
  pub fn add_orchard(&mut self, orchard: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(UAReceivers::VT_ORCHARD, orchard);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> UAReceiversBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    UAReceiversBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<UAReceivers<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for UAReceivers<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("UAReceivers");
      ds.field("transparent", &self.transparent());
      ds.field("sapling", &self.sapling());
      ds.field("orchard", &self.orchard());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Serialize, Deserialize, Debug, Clone, PartialEq)]
pub struct UAReceiversT {
  pub transparent: Option<String>,
  pub sapling: Option<String>,
  pub orchard: Option<String>,
}
impl Default for UAReceiversT {
  fn default() -> Self {
    Self {
      transparent: None,
      sapling: None,
      orchard: None,
    }
  }
}
impl UAReceiversT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<UAReceivers<'b>> {
    let transparent = self.transparent.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let sapling = self.sapling.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let orchard = self.orchard.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    UAReceivers::create(_fbb, &UAReceiversArgs{
      transparent,
      sapling,
      orchard,
    })
  }
}
pub enum PaymentRequestOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct PaymentRequest<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for PaymentRequest<'a> {
  type Inner = PaymentRequest<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> PaymentRequest<'a> {
  pub const VT_ADDRESS: flatbuffers::VOffsetT = 4;
  pub const VT_AMOUNT: flatbuffers::VOffsetT = 6;
  pub const VT_MEMO_STRING: flatbuffers::VOffsetT = 8;
  pub const VT_MEMO_BYTES: flatbuffers::VOffsetT = 10;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    PaymentRequest { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args PaymentRequestArgs<'args>
  ) -> flatbuffers::WIPOffset<PaymentRequest<'bldr>> {
    let mut builder = PaymentRequestBuilder::new(_fbb);
    builder.add_amount(args.amount);
    if let Some(x) = args.memo_bytes { builder.add_memo_bytes(x); }
    if let Some(x) = args.memo_string { builder.add_memo_string(x); }
    if let Some(x) = args.address { builder.add_address(x); }
    builder.finish()
  }

  pub fn unpack(&self) -> PaymentRequestT {
    let address = self.address().map(|x| {
      x.to_string()
    });
    let amount = self.amount();
    let memo_string = self.memo_string().map(|x| {
      x.to_string()
    });
    let memo_bytes = self.memo_bytes().map(|x| {
      x.into_iter().collect()
    });
    PaymentRequestT {
      address,
      amount,
      memo_string,
      memo_bytes,
    }
  }

  #[inline]
  pub fn address(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(PaymentRequest::VT_ADDRESS, None)}
  }
  #[inline]
  pub fn amount(&self) -> u64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u64>(PaymentRequest::VT_AMOUNT, Some(0)).unwrap()}
  }
  #[inline]
  pub fn memo_string(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(PaymentRequest::VT_MEMO_STRING, None)}
  }
  #[inline]
  pub fn memo_bytes(&self) -> Option<flatbuffers::Vector<'a, u8>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(PaymentRequest::VT_MEMO_BYTES, None)}
  }
}

impl flatbuffers::Verifiable for PaymentRequest<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("address", Self::VT_ADDRESS, false)?
     .visit_field::<u64>("amount", Self::VT_AMOUNT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("memo_string", Self::VT_MEMO_STRING, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>("memo_bytes", Self::VT_MEMO_BYTES, false)?
     .finish();
    Ok(())
  }
}
pub struct PaymentRequestArgs<'a> {
    pub address: Option<flatbuffers::WIPOffset<&'a str>>,
    pub amount: u64,
    pub memo_string: Option<flatbuffers::WIPOffset<&'a str>>,
    pub memo_bytes: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
}
impl<'a> Default for PaymentRequestArgs<'a> {
  #[inline]
  fn default() -> Self {
    PaymentRequestArgs {
      address: None,
      amount: 0,
      memo_string: None,
      memo_bytes: None,
    }
  }
}

pub struct PaymentRequestBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> PaymentRequestBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_address(&mut self, address: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(PaymentRequest::VT_ADDRESS, address);
  }
  #[inline]
  pub fn add_amount(&mut self, amount: u64) {
    self.fbb_.push_slot::<u64>(PaymentRequest::VT_AMOUNT, amount, 0);
  }
  #[inline]
  pub fn add_memo_string(&mut self, memo_string: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(PaymentRequest::VT_MEMO_STRING, memo_string);
  }
  #[inline]
  pub fn add_memo_bytes(&mut self, memo_bytes: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(PaymentRequest::VT_MEMO_BYTES, memo_bytes);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> PaymentRequestBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    PaymentRequestBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<PaymentRequest<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for PaymentRequest<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("PaymentRequest");
      ds.field("address", &self.address());
      ds.field("amount", &self.amount());
      ds.field("memo_string", &self.memo_string());
      ds.field("memo_bytes", &self.memo_bytes());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Serialize, Deserialize, Debug, Clone, PartialEq)]
pub struct PaymentRequestT {
  pub address: Option<String>,
  pub amount: u64,
  pub memo_string: Option<String>,
  pub memo_bytes: Option<Vec<u8>>,
}
impl Default for PaymentRequestT {
  fn default() -> Self {
    Self {
      address: None,
      amount: 0,
      memo_string: None,
      memo_bytes: None,
    }
  }
}
impl PaymentRequestT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<PaymentRequest<'b>> {
    let address = self.address.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let amount = self.amount;
    let memo_string = self.memo_string.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let memo_bytes = self.memo_bytes.as_ref().map(|x|{
      _fbb.create_vector(x)
    });
    PaymentRequest::create(_fbb, &PaymentRequestArgs{
      address,
      amount,
      memo_string,
      memo_bytes,
    })
  }
}
pub enum AccountNameOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct AccountName<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for AccountName<'a> {
  type Inner = AccountName<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> AccountName<'a> {
  pub const VT_ID: flatbuffers::VOffsetT = 4;
  pub const VT_NAME: flatbuffers::VOffsetT = 6;
  pub const VT_SAPLING_ADDRESS: flatbuffers::VOffsetT = 8;
  pub const VT_BIRTH: flatbuffers::VOffsetT = 10;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    AccountName { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args AccountNameArgs<'args>
  ) -> flatbuffers::WIPOffset<AccountName<'bldr>> {
    let mut builder = AccountNameBuilder::new(_fbb);
    builder.add_birth(args.birth);
    if let Some(x) = args.sapling_address { builder.add_sapling_address(x); }
    if let Some(x) = args.name { builder.add_name(x); }
    builder.add_id(args.id);
    builder.finish()
  }

  pub fn unpack(&self) -> AccountNameT {
    let id = self.id();
    let name = self.name().map(|x| {
      x.to_string()
    });
    let sapling_address = self.sapling_address().map(|x| {
      x.to_string()
    });
    let birth = self.birth();
    AccountNameT {
      id,
      name,
      sapling_address,
      birth,
    }
  }

  #[inline]
  pub fn id(&self) -> u32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u32>(AccountName::VT_ID, Some(0)).unwrap()}
  }
  #[inline]
  pub fn name(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(AccountName::VT_NAME, None)}
  }
  #[inline]
  pub fn sapling_address(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(AccountName::VT_SAPLING_ADDRESS, None)}
  }
  #[inline]
  pub fn birth(&self) -> u32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u32>(AccountName::VT_BIRTH, Some(0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for AccountName<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<u32>("id", Self::VT_ID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("name", Self::VT_NAME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("sapling_address", Self::VT_SAPLING_ADDRESS, false)?
     .visit_field::<u32>("birth", Self::VT_BIRTH, false)?
     .finish();
    Ok(())
  }
}
pub struct AccountNameArgs<'a> {
    pub id: u32,
    pub name: Option<flatbuffers::WIPOffset<&'a str>>,
    pub sapling_address: Option<flatbuffers::WIPOffset<&'a str>>,
    pub birth: u32,
}
impl<'a> Default for AccountNameArgs<'a> {
  #[inline]
  fn default() -> Self {
    AccountNameArgs {
      id: 0,
      name: None,
      sapling_address: None,
      birth: 0,
    }
  }
}

pub struct AccountNameBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> AccountNameBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_id(&mut self, id: u32) {
    self.fbb_.push_slot::<u32>(AccountName::VT_ID, id, 0);
  }
  #[inline]
  pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(AccountName::VT_NAME, name);
  }
  #[inline]
  pub fn add_sapling_address(&mut self, sapling_address: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(AccountName::VT_SAPLING_ADDRESS, sapling_address);
  }
  #[inline]
  pub fn add_birth(&mut self, birth: u32) {
    self.fbb_.push_slot::<u32>(AccountName::VT_BIRTH, birth, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> AccountNameBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    AccountNameBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<AccountName<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for AccountName<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("AccountName");
      ds.field("id", &self.id());
      ds.field("name", &self.name());
      ds.field("sapling_address", &self.sapling_address());
      ds.field("birth", &self.birth());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Serialize, Deserialize, Debug, Clone, PartialEq)]
pub struct AccountNameT {
  pub id: u32,
  pub name: Option<String>,
  pub sapling_address: Option<String>,
  pub birth: u32,
}
impl Default for AccountNameT {
  fn default() -> Self {
    Self {
      id: 0,
      name: None,
      sapling_address: None,
      birth: 0,
    }
  }
}
impl AccountNameT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<AccountName<'b>> {
    let id = self.id;
    let name = self.name.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let sapling_address = self.sapling_address.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let birth = self.birth;
    AccountName::create(_fbb, &AccountNameArgs{
      id,
      name,
      sapling_address,
      birth,
    })
  }
}
pub enum ContactCardOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct ContactCard<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ContactCard<'a> {
  type Inner = ContactCard<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> ContactCard<'a> {
  pub const VT_ID: flatbuffers::VOffsetT = 4;
  pub const VT_ACCOUNT: flatbuffers::VOffsetT = 6;
  pub const VT_NAME: flatbuffers::VOffsetT = 8;
  pub const VT_ADDRESS: flatbuffers::VOffsetT = 10;
  pub const VT_SAVED: flatbuffers::VOffsetT = 12;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    ContactCard { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args ContactCardArgs<'args>
  ) -> flatbuffers::WIPOffset<ContactCard<'bldr>> {
    let mut builder = ContactCardBuilder::new(_fbb);
    if let Some(x) = args.address { builder.add_address(x); }
    if let Some(x) = args.name { builder.add_name(x); }
    builder.add_account(args.account);
    builder.add_id(args.id);
    builder.add_saved(args.saved);
    builder.finish()
  }

  pub fn unpack(&self) -> ContactCardT {
    let id = self.id();
    let account = self.account();
    let name = self.name().map(|x| {
      x.to_string()
    });
    let address = self.address().map(|x| {
      x.to_string()
    });
    let saved = self.saved();
    ContactCardT {
      id,
      account,
      name,
      address,
      saved,
    }
  }

  #[inline]
  pub fn id(&self) -> u32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u32>(ContactCard::VT_ID, Some(0)).unwrap()}
  }
  #[inline]
  pub fn account(&self) -> u32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u32>(ContactCard::VT_ACCOUNT, Some(0)).unwrap()}
  }
  #[inline]
  pub fn name(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(ContactCard::VT_NAME, None)}
  }
  #[inline]
  pub fn address(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(ContactCard::VT_ADDRESS, None)}
  }
  #[inline]
  pub fn saved(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(ContactCard::VT_SAVED, Some(false)).unwrap()}
  }
}

impl flatbuffers::Verifiable for ContactCard<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<u32>("id", Self::VT_ID, false)?
     .visit_field::<u32>("account", Self::VT_ACCOUNT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("name", Self::VT_NAME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("address", Self::VT_ADDRESS, false)?
     .visit_field::<bool>("saved", Self::VT_SAVED, false)?
     .finish();
    Ok(())
  }
}
pub struct ContactCardArgs<'a> {
    pub id: u32,
    pub account: u32,
    pub name: Option<flatbuffers::WIPOffset<&'a str>>,
    pub address: Option<flatbuffers::WIPOffset<&'a str>>,
    pub saved: bool,
}
impl<'a> Default for ContactCardArgs<'a> {
  #[inline]
  fn default() -> Self {
    ContactCardArgs {
      id: 0,
      account: 0,
      name: None,
      address: None,
      saved: false,
    }
  }
}

pub struct ContactCardBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> ContactCardBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_id(&mut self, id: u32) {
    self.fbb_.push_slot::<u32>(ContactCard::VT_ID, id, 0);
  }
  #[inline]
  pub fn add_account(&mut self, account: u32) {
    self.fbb_.push_slot::<u32>(ContactCard::VT_ACCOUNT, account, 0);
  }
  #[inline]
  pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ContactCard::VT_NAME, name);
  }
  #[inline]
  pub fn add_address(&mut self, address: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ContactCard::VT_ADDRESS, address);
  }
  #[inline]
  pub fn add_saved(&mut self, saved: bool) {
    self.fbb_.push_slot::<bool>(ContactCard::VT_SAVED, saved, false);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> ContactCardBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    ContactCardBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<ContactCard<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for ContactCard<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("ContactCard");
      ds.field("id", &self.id());
      ds.field("account", &self.account());
      ds.field("name", &self.name());
      ds.field("address", &self.address());
      ds.field("saved", &self.saved());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Serialize, Deserialize, Debug, Clone, PartialEq)]
pub struct ContactCardT {
  pub id: u32,
  pub account: u32,
  pub name: Option<String>,
  pub address: Option<String>,
  pub saved: bool,
}
impl Default for ContactCardT {
  fn default() -> Self {
    Self {
      id: 0,
      account: 0,
      name: None,
      address: None,
      saved: false,
    }
  }
}
impl ContactCardT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<ContactCard<'b>> {
    let id = self.id;
    let account = self.account;
    let name = self.name.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let address = self.address.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let saved = self.saved;
    ContactCard::create(_fbb, &ContactCardArgs{
      id,
      account,
      name,
      address,
      saved,
    })
  }
}
pub enum TransactionRecipientOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct TransactionRecipient<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for TransactionRecipient<'a> {
  type Inner = TransactionRecipient<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> TransactionRecipient<'a> {
  pub const VT_ADDRESS: flatbuffers::VOffsetT = 4;
  pub const VT_AMOUNT: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    TransactionRecipient { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args TransactionRecipientArgs<'args>
  ) -> flatbuffers::WIPOffset<TransactionRecipient<'bldr>> {
    let mut builder = TransactionRecipientBuilder::new(_fbb);
    builder.add_amount(args.amount);
    if let Some(x) = args.address { builder.add_address(x); }
    builder.finish()
  }

  pub fn unpack(&self) -> TransactionRecipientT {
    let address = self.address().map(|x| {
      x.to_string()
    });
    let amount = self.amount();
    TransactionRecipientT {
      address,
      amount,
    }
  }

  #[inline]
  pub fn address(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(TransactionRecipient::VT_ADDRESS, None)}
  }
  #[inline]
  pub fn amount(&self) -> u64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u64>(TransactionRecipient::VT_AMOUNT, Some(0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for TransactionRecipient<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("address", Self::VT_ADDRESS, false)?
     .visit_field::<u64>("amount", Self::VT_AMOUNT, false)?
     .finish();
    Ok(())
  }
}
pub struct TransactionRecipientArgs<'a> {
    pub address: Option<flatbuffers::WIPOffset<&'a str>>,
    pub amount: u64,
}
impl<'a> Default for TransactionRecipientArgs<'a> {
  #[inline]
  fn default() -> Self {
    TransactionRecipientArgs {
      address: None,
      amount: 0,
    }
  }
}

pub struct TransactionRecipientBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> TransactionRecipientBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_address(&mut self, address: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(TransactionRecipient::VT_ADDRESS, address);
  }
  #[inline]
  pub fn add_amount(&mut self, amount: u64) {
    self.fbb_.push_slot::<u64>(TransactionRecipient::VT_AMOUNT, amount, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> TransactionRecipientBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    TransactionRecipientBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<TransactionRecipient<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for TransactionRecipient<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("TransactionRecipient");
      ds.field("address", &self.address());
      ds.field("amount", &self.amount());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Serialize, Deserialize, Debug, Clone, PartialEq)]
pub struct TransactionRecipientT {
  pub address: Option<String>,
  pub amount: u64,
}
impl Default for TransactionRecipientT {
  fn default() -> Self {
    Self {
      address: None,
      amount: 0,
    }
  }
}
impl TransactionRecipientT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<TransactionRecipient<'b>> {
    let address = self.address.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let amount = self.amount;
    TransactionRecipient::create(_fbb, &TransactionRecipientArgs{
      address,
      amount,
    })
  }
}
pub enum TransactionSummaryOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct TransactionSummary<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for TransactionSummary<'a> {
  type Inner = TransactionSummary<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> TransactionSummary<'a> {
  pub const VT_RECIPIENTS: flatbuffers::VOffsetT = 4;
  pub const VT_TRANSPARENT_INS: flatbuffers::VOffsetT = 6;
  pub const VT_SAPLING_NET: flatbuffers::VOffsetT = 8;
  pub const VT_ORCHARD_NET: flatbuffers::VOffsetT = 10;
  pub const VT_FEE: flatbuffers::VOffsetT = 12;
  pub const VT_DATA: flatbuffers::VOffsetT = 14;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    TransactionSummary { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args TransactionSummaryArgs<'args>
  ) -> flatbuffers::WIPOffset<TransactionSummary<'bldr>> {
    let mut builder = TransactionSummaryBuilder::new(_fbb);
    builder.add_fee(args.fee);
    builder.add_orchard_net(args.orchard_net);
    builder.add_sapling_net(args.sapling_net);
    builder.add_transparent_ins(args.transparent_ins);
    if let Some(x) = args.data { builder.add_data(x); }
    if let Some(x) = args.recipients { builder.add_recipients(x); }
    builder.finish()
  }

  pub fn unpack(&self) -> TransactionSummaryT {
    let recipients = self.recipients().map(|x| {
      x.iter().map(|t| t.unpack()).collect()
    });
    let transparent_ins = self.transparent_ins();
    let sapling_net = self.sapling_net();
    let orchard_net = self.orchard_net();
    let fee = self.fee();
    let data = self.data().map(|x| {
      x.into_iter().collect()
    });
    TransactionSummaryT {
      recipients,
      transparent_ins,
      sapling_net,
      orchard_net,
      fee,
      data,
    }
  }

  #[inline]
  pub fn recipients(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<TransactionRecipient<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<TransactionRecipient>>>>(TransactionSummary::VT_RECIPIENTS, None)}
  }
  #[inline]
  pub fn transparent_ins(&self) -> u64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u64>(TransactionSummary::VT_TRANSPARENT_INS, Some(0)).unwrap()}
  }
  #[inline]
  pub fn sapling_net(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(TransactionSummary::VT_SAPLING_NET, Some(0)).unwrap()}
  }
  #[inline]
  pub fn orchard_net(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(TransactionSummary::VT_ORCHARD_NET, Some(0)).unwrap()}
  }
  #[inline]
  pub fn fee(&self) -> u64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u64>(TransactionSummary::VT_FEE, Some(0)).unwrap()}
  }
  #[inline]
  pub fn data(&self) -> Option<flatbuffers::Vector<'a, u8>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(TransactionSummary::VT_DATA, None)}
  }
}

impl flatbuffers::Verifiable for TransactionSummary<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<TransactionRecipient>>>>("recipients", Self::VT_RECIPIENTS, false)?
     .visit_field::<u64>("transparent_ins", Self::VT_TRANSPARENT_INS, false)?
     .visit_field::<i64>("sapling_net", Self::VT_SAPLING_NET, false)?
     .visit_field::<i64>("orchard_net", Self::VT_ORCHARD_NET, false)?
     .visit_field::<u64>("fee", Self::VT_FEE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>("data", Self::VT_DATA, false)?
     .finish();
    Ok(())
  }
}
pub struct TransactionSummaryArgs<'a> {
    pub recipients: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<TransactionRecipient<'a>>>>>,
    pub transparent_ins: u64,
    pub sapling_net: i64,
    pub orchard_net: i64,
    pub fee: u64,
    pub data: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
}
impl<'a> Default for TransactionSummaryArgs<'a> {
  #[inline]
  fn default() -> Self {
    TransactionSummaryArgs {
      recipients: None,
      transparent_ins: 0,
      sapling_net: 0,
      orchard_net: 0,
      fee: 0,
      data: None,
    }
  }
}

pub struct TransactionSummaryBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> TransactionSummaryBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_recipients(&mut self, recipients: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<TransactionRecipient<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(TransactionSummary::VT_RECIPIENTS, recipients);
  }
  #[inline]
  pub fn add_transparent_ins(&mut self, transparent_ins: u64) {
    self.fbb_.push_slot::<u64>(TransactionSummary::VT_TRANSPARENT_INS, transparent_ins, 0);
  }
  #[inline]
  pub fn add_sapling_net(&mut self, sapling_net: i64) {
    self.fbb_.push_slot::<i64>(TransactionSummary::VT_SAPLING_NET, sapling_net, 0);
  }
  #[inline]
  pub fn add_orchard_net(&mut self, orchard_net: i64) {
    self.fbb_.push_slot::<i64>(TransactionSummary::VT_ORCHARD_NET, orchard_net, 0);
  }
  #[inline]
  pub fn add_fee(&mut self, fee: u64) {
    self.fbb_.push_slot::<u64>(TransactionSummary::VT_FEE, fee, 0);
  }
  #[inline]
  pub fn add_data(&mut self, data: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(TransactionSummary::VT_DATA, data);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> TransactionSummaryBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    TransactionSummaryBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<TransactionSummary<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for TransactionSummary<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("TransactionSummary");
      ds.field("recipients", &self.recipients());
      ds.field("transparent_ins", &self.transparent_ins());
      ds.field("sapling_net", &self.sapling_net());
      ds.field("orchard_net", &self.orchard_net());
      ds.field("fee", &self.fee());
      ds.field("data", &self.data());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Serialize, Deserialize, Debug, Clone, PartialEq)]
pub struct TransactionSummaryT {
  pub recipients: Option<Vec<TransactionRecipientT>>,
  pub transparent_ins: u64,
  pub sapling_net: i64,
  pub orchard_net: i64,
  pub fee: u64,
  pub data: Option<Vec<u8>>,
}
impl Default for TransactionSummaryT {
  fn default() -> Self {
    Self {
      recipients: None,
      transparent_ins: 0,
      sapling_net: 0,
      orchard_net: 0,
      fee: 0,
      data: None,
    }
  }
}
impl TransactionSummaryT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<TransactionSummary<'b>> {
    let recipients = self.recipients.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();_fbb.create_vector(&w)
    });
    let transparent_ins = self.transparent_ins;
    let sapling_net = self.sapling_net;
    let orchard_net = self.orchard_net;
    let fee = self.fee;
    let data = self.data.as_ref().map(|x|{
      _fbb.create_vector(x)
    });
    TransactionSummary::create(_fbb, &TransactionSummaryArgs{
      recipients,
      transparent_ins,
      sapling_net,
      orchard_net,
      fee,
      data,
    })
  }
}
}  // pub mod fb

